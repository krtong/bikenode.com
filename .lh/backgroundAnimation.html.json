{
    "sourceFile": "backgroundAnimation.html",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 3,
            "patches": [
                {
                    "date": 1740658348023,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1740658399701,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -2,9 +2,9 @@\n <html lang=\"en\">\n <head>\n     <meta charset=\"UTF-8\">\n     <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n-    <title>Enhanced 3D Wireframe Background</title>\n+    <title>Enhanced 3D Wireframe Road Background</title>\n     <style>\n         * {\n             margin: 0;\n             padding: 0;\n@@ -22,9 +22,9 @@\n             left: 0;\n             width: 100%;\n             height: 100%;\n             z-index: -1;\n-            opacity: 0.2; /* Subtle background */\n+            opacity: 0.2; /* Keeps it subtle as a background */\n         }\n     </style>\n </head>\n <body>\n@@ -43,16 +43,17 @@\n             window.addEventListener('resize', resizeCanvas);\n             resizeCanvas();\n \n             // Configuration\n-            const segmentLength = 100;     // Length of each road segment\n-            const roadWidth = 2000;        // Width in world units\n-            const segmentCount = 200;      // Number of segments\n-            const cameraHeight = 1000;     // Camera height above road\n+            const segmentLength = 100;     // Length of each road segment in world units\n+            const roadWidth = 2000;        // Width of the road in world units\n+            const segmentCount = 200;      // Total number of segments\n+            const cameraHeight = 1000;     // Camera height above the road\n             const cameraDepth = 0.84;      // Perspective factor\n             const fov = 100;               // Field of view\n             let cameraZ = 0;               // Camera position along Z-axis\n             const segments = [];\n+            const trees = [];\n \n             // Generate road segments with curves and hills\n             for (let i = 0; i < segmentCount; i++) {\n                 segments.push({\n@@ -63,14 +64,20 @@\n                     hill: Math.cos(i / 30) * 600    // Smooth vertical hills\n                 });\n             }\n \n+            // Generate trees along the roadside\n+            for (let z = 0; z < segmentCount * segmentLength; z += 500) {\n+                trees.push({ x: -roadWidth * 1.5, y: 0, z: z }); // Left side\n+                trees.push({ x: roadWidth * 1.5, y: 0, z: z });  // Right side\n+            }\n+\n             // Project 3D point to 2D screen coordinates\n             function project(point, camX, camY, camZ) {\n                 const dx = point.world.x - camX;\n                 const dy = point.world.y - camY;\n                 const dz = point.world.z - camZ;\n-                const scale = fov / (dz > 0 ? dz : 0.001); // Prevent division by zero\n+                const scale = fov / (dz > 0 ? dz : 0.001); // Avoid division by zero\n                 point.screen.x = canvas.width / 2 + scale * dx;\n                 point.screen.y = canvas.height / 2 - scale * dy;\n                 point.screen.scale = scale;\n             }\n@@ -87,27 +94,27 @@\n             // Render the scene\n             function render() {\n                 ctx.clearRect(0, 0, canvas.width, canvas.height);\n \n-                // Horizon gradient for depth\n+                // Draw horizon gradient for depth\n                 const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);\n-                gradient.addColorStop(0, '#2a2d34');\n-                gradient.addColorStop(0.5, '#1a1c1f');\n+                gradient.addColorStop(0, '#2a2d34'); // Sky-like\n+                gradient.addColorStop(0.5, '#1a1c1f'); // Ground-like\n                 ctx.fillStyle = gradient;\n                 ctx.fillRect(0, 0, canvas.width, canvas.height);\n \n-                ctx.strokeStyle = '#5865F2'; // Retro-inspired color\n+                ctx.strokeStyle = '#5865F2'; // Retro wireframe color\n                 ctx.lineWidth = 1;\n \n                 // Move camera forward\n                 cameraZ += 150; // Speed of movement\n                 if (cameraZ >= segmentCount * segmentLength) {\n-                    cameraZ -= segmentCount * segmentLength;\n+                    cameraZ -= segmentCount * segmentLength; // Loop back\n                 }\n \n                 const baseSegmentIdx = Math.floor(cameraZ / segmentLength) % segmentCount;\n \n-                // Draw segments from back to front\n+                // Draw road segments from back to front\n                 for (let i = segmentCount - 1; i >= 0; i--) {\n                     const segment = segments[(baseSegmentIdx + i) % segmentCount];\n                     const nextSegment = segments[(segment.index + 1) % segmentCount];\n \n@@ -125,30 +132,34 @@\n                     if (segment.p1.screen.scale <= 0) continue;\n \n                     const p1 = segment.p1.screen;\n                     const p2 = segment.p2.screen;\n-                    const fade = Math.min(1, p1.scale * 2); // Fade distant lines\n+                    const fade = Math.min(1, p1.scale * 2); // Fade with distance\n \n                     // Calculate road edges\n                     const width1 = (roadWidth / 2) * p1.scale;\n                     const width2 = (roadWidth / 2) * p2.scale;\n \n-                    // Draw road edges\n-                    drawLine(p1.x - width1, p1.y, p2.x - width2, p2.y, fade);\n-                    drawLine(p1.x + width1, p1.y, p2.x + width2, p2.y, fade);\n+                    // Draw solid road edges\n+                    drawLine(p1.x - width1, p1.y, p2.x - width2, p2.y, fade); // Left edge\n+                    drawLine(p1.x + width1, p1.y, p2.x + width2, p2.y, fade); // Right edge\n \n-                    // Draw grid lines\n-                    if (i % 4 === 0) {\n-                        // Horizontal grid across road\n-                        drawLine(p1.x - width1, p1.y, p1.x + width1, p1.y, fade);\n+                    // Draw dashed center line\n+                    const midZ = (segment.p1.world.z + segment.p2.world.z) / 2;\n+                    if (midZ % 200 < 100) {\n+                        drawLine(p1.x, p1.y, p2.x, p2.y, fade);\n+                    }\n+                }\n \n-                        // Vertical grid lines (converging)\n-                        for (let j = -4; j <= 4; j++) {\n-                            const offset = j * (roadWidth / 8);\n-                            const gridX1 = p1.x + offset * p1.scale;\n-                            const gridX2 = p2.x + offset * p2.scale;\n-                            drawLine(gridX1, p1.y, gridX2, p2.y, fade);\n-                        }\n+                // Draw roadside trees\n+                for (let tree of trees) {\n+                    const treePoint = { world: tree, screen: {} };\n+                    project(treePoint, 0, cameraHeight, cameraZ);\n+                    if (treePoint.screen.scale > 0) {\n+                        const x = treePoint.screen.x;\n+                        const y = treePoint.screen.y;\n+                        const height = 500 * treePoint.screen.scale; // Tree height scales with distance\n+                        drawLine(x, y, x, y - height, treePoint.screen.scale * 0.5); // Fade with distance\n                     }\n                 }\n \n                 requestAnimationFrame(render);\n"
                },
                {
                    "date": 1740658700396,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -52,35 +52,35 @@\n             const fov = 100;               // Field of view\n             let cameraZ = 0;               // Camera position along Z-axis\n             const segments = [];\n             const trees = [];\n+            const stars = [];              // New array for starfield\n+            const mountains = [];          // New array for background mountains\n \n-            // Generate road segments with curves and hills\n-            for (let i = 0; i < segmentCount; i++) {\n-                segments.push({\n-                    index: i,\n-                    p1: { world: { x: 0, y: 0, z: i * segmentLength }, screen: {} },\n-                    p2: { world: { x: 0, y: 0, z: (i + 1) * segmentLength }, screen: {} },\n-                    curve: Math.sin(i / 20) * 1200, // Smooth horizontal curves\n-                    hill: Math.cos(i / 30) * 600    // Smooth vertical hills\n+            // Generate stars for the background\n+            for (let i = 0; i < 200; i++) {\n+                stars.push({\n+                    x: Math.random() * canvas.width,\n+                    y: Math.random() * canvas.height * 0.5, // Only in upper half\n+                    size: Math.random() * 1.5 + 0.5,\n+                    brightness: Math.random() * 0.8 + 0.2\n                 });\n             }\n-\n-            // Generate trees along the roadside\n-            for (let z = 0; z < segmentCount * segmentLength; z += 500) {\n-                trees.push({ x: -roadWidth * 1.5, y: 0, z: z }); // Left side\n-                trees.push({ x: roadWidth * 1.5, y: 0, z: z });  // Right side\n+            \n+            // Generate mountain peaks for the background\n+            const mountainPoints = 15;\n+            const mountainBaseY = canvas.height * 0.4;\n+            for (let i = 0; i < mountainPoints; i++) {\n+                mountains.push({\n+                    x: (i / (mountainPoints - 1)) * canvas.width,\n+                    y: mountainBaseY - Math.abs(Math.sin(i * 0.5) * canvas.height * 0.15)\n+                                     - Math.random() * canvas.height * 0.1\n+                });\n             }\n \n-            // Project 3D point to 2D screen coordinates\n-            function project(point, camX, camY, camZ) {\n-                const dx = point.world.x - camX;\n-                const dy = point.world.y - camY;\n-                const dz = point.world.z - camZ;\n-                const scale = fov / (dz > 0 ? dz : 0.001); // Avoid division by zero\n-                point.screen.x = canvas.width / 2 + scale * dx;\n-                point.screen.y = canvas.height / 2 - scale * dy;\n-                point.screen.scale = scale;\n+            // Generate road segments with curves and hills\n+            for (let i = 0; i < segmentCount; i++) {\n+                segments.push({\n             }\n \n             // Draw a line with optional alpha for fading\n             function drawLine(x1, y1, x2, y2, alpha = 1) {\n"
                },
                {
                    "date": 1740658758600,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -79,10 +79,54 @@\n \n             // Generate road segments with curves and hills\n             for (let i = 0; i < segmentCount; i++) {\n                 segments.push({\n+                    index: i,\n+                    p1: { world: { x: 0, y: 0, z: i * segmentLength }, screen: {} },\n+                    p2: { world: { x: 0, y: 0, z: (i + 1) * segmentLength }, screen: {} },\n+                    curve: Math.sin(i / 20) * 1200, // Smooth horizontal curves\n+                    hill: Math.cos(i / 30) * 600,   // Smooth vertical hills\n+                    color: i % 10 === 0 ? '#7289DA' : '#5865F2' // Color variation for every 10th segment\n+                });\n             }\n \n+            // Generate trees and structures along the roadside\n+            for (let z = 0; z < segmentCount * segmentLength; z += 500) {\n+                // Trees on both sides\n+                trees.push({ x: -roadWidth * 1.5, y: 0, z: z }); // Left side\n+                trees.push({ x: roadWidth * 1.5, y: 0, z: z });  // Right side\n+                \n+                // Add occasional structures (like towers)\n+                if (z % 2000 < 100) {\n+                    trees.push({ \n+                        x: -roadWidth * 2.5, \n+                        y: 0, \n+                        z: z,\n+                        isStructure: true,\n+                        height: 1500 + Math.random() * 1000\n+                    });\n+                    \n+                    trees.push({ \n+                        x: roadWidth * 2.5, \n+                        y: 0, \n+                        z: z,\n+                        isStructure: true,\n+                        height: 1500 + Math.random() * 1000\n+                    });\n+                }\n+            }\n+\n+            // Project 3D point to 2D screen coordinates\n+            function project(point, camX, camY, camZ) {\n+                const dx = point.world.x - camX;\n+                const dy = point.world.y - camY;\n+                const dz = point.world.z - camZ;\n+                const scale = fov / (dz > 0 ? dz : 0.001); // Avoid division by zero\n+                point.screen.x = canvas.width / 2 + scale * dx;\n+                point.screen.y = canvas.height / 2 - scale * dy;\n+                point.screen.scale = scale;\n+            }\n+\n             // Draw a line with optional alpha for fading\n             function drawLine(x1, y1, x2, y2, alpha = 1) {\n                 ctx.globalAlpha = alpha;\n                 ctx.beginPath();\n@@ -90,29 +134,77 @@\n                 ctx.lineTo(x2, y2);\n                 ctx.stroke();\n             }\n \n+            // Draw a star\n+            function drawStar(star) {\n+                ctx.globalAlpha = star.brightness;\n+                ctx.beginPath();\n+                ctx.arc(star.x, star.y, star.size, 0, Math.PI * 2);\n+                ctx.fillStyle = '#FFFFFF';\n+                ctx.fill();\n+            }\n+            \n+            // Last timestamp for frame timing\n+            let lastTime = performance.now();\n+            const targetFPS = 60;\n+            const frameTime = 1000 / targetFPS;\n+\n             // Render the scene\n-            function render() {\n+            function render(timestamp) {\n+                // Calculate delta time for consistent animation speed\n+                const deltaTime = timestamp - lastTime;\n+                if (deltaTime < frameTime - 1) {\n+                    requestAnimationFrame(render);\n+                    return; // Skip frame to maintain target FPS\n+                }\n+                lastTime = timestamp;\n+                \n                 ctx.clearRect(0, 0, canvas.width, canvas.height);\n \n                 // Draw horizon gradient for depth\n                 const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);\n-                gradient.addColorStop(0, '#2a2d34'); // Sky-like\n-                gradient.addColorStop(0.5, '#1a1c1f'); // Ground-like\n+                gradient.addColorStop(0, '#121417'); // Darker sky for contrast with stars\n+                gradient.addColorStop(0.4, '#1e2228'); // Mid sky\n+                gradient.addColorStop(0.5, '#1a1c1f'); // Horizon\n+                gradient.addColorStop(1, '#161719'); // Ground\n                 ctx.fillStyle = gradient;\n                 ctx.fillRect(0, 0, canvas.width, canvas.height);\n \n+                // Draw stars\n+                for (const star of stars) {\n+                    drawStar(star);\n+                }\n+                \n+                // Draw mountain skyline\n+                ctx.globalAlpha = 0.5;\n+                ctx.strokeStyle = '#3b4152';\n+                ctx.lineWidth = 1.5;\n+                ctx.beginPath();\n+                ctx.moveTo(0, mountainBaseY);\n+                for (const peak of mountains) {\n+                    ctx.lineTo(peak.x, peak.y);\n+                }\n+                ctx.lineTo(canvas.width, mountainBaseY);\n+                ctx.stroke();\n+\n+                // Reset for road and elements\n                 ctx.strokeStyle = '#5865F2'; // Retro wireframe color\n                 ctx.lineWidth = 1;\n+                ctx.globalAlpha = 1;\n \n                 // Move camera forward\n-                cameraZ += 150; // Speed of movement\n+                cameraZ += 150 * (deltaTime / frameTime); // Speed adjusted for frame timing\n                 if (cameraZ >= segmentCount * segmentLength) {\n                     cameraZ -= segmentCount * segmentLength; // Loop back\n                 }\n \n                 const baseSegmentIdx = Math.floor(cameraZ / segmentLength) % segmentCount;\n+                \n+                // Calculate a slight bounce effect based on terrain\n+                const currentSegmentIndex = Math.floor(cameraZ / segmentLength);\n+                const currentSegment = segments[currentSegmentIndex % segmentCount];\n+                const bounceOffset = currentSegment ? Math.sin(cameraZ / 200) * 50 : 0;\n \n                 // Draw road segments from back to front\n                 for (let i = segmentCount - 1; i >= 0; i--) {\n                     const segment = segments[(baseSegmentIdx + i) % segmentCount];\n@@ -124,18 +216,24 @@\n                     segment.p2.world.x = nextSegment.curve;\n                     segment.p2.world.y = nextSegment.hill;\n \n                     // Project points to screen\n-                    project(segment.p1, 0, cameraHeight, cameraZ);\n-                    project(segment.p2, 0, cameraHeight, cameraZ);\n+                    project(segment.p1, 0, cameraHeight + bounceOffset, cameraZ);\n+                    project(segment.p2, 0, cameraHeight + bounceOffset, cameraZ);\n \n                     // Skip segments behind camera\n                     if (segment.p1.screen.scale <= 0) continue;\n \n                     const p1 = segment.p1.screen;\n                     const p2 = segment.p2.screen;\n-                    const fade = Math.min(1, p1.scale * 2); // Fade with distance\n+                    \n+                    // Improved distance-based fading with fog effect\n+                    const fogFactor = 1 - Math.min(1, i / (segmentCount * 0.8));\n+                    const fade = Math.min(1, p1.scale * 2) * fogFactor;\n \n+                    // Set color based on segment\n+                    ctx.strokeStyle = segment.color;\n+                    \n                     // Calculate road edges\n                     const width1 = (roadWidth / 2) * p1.scale;\n                     const width2 = (roadWidth / 2) * p2.scale;\n \n@@ -147,26 +245,93 @@\n                     const midZ = (segment.p1.world.z + segment.p2.world.z) / 2;\n                     if (midZ % 200 < 100) {\n                         drawLine(p1.x, p1.y, p2.x, p2.y, fade);\n                     }\n+                    \n+                    // Draw cross grid lines every 5 segments\n+                    if (segment.index % 5 === 0) {\n+                        // Horizontal grid lines\n+                        for (let j = -2; j <= 2; j++) {\n+                            const laneDivision = j * (width1 / 3);\n+                            const nextLaneDivision = j * (width2 / 3);\n+                            drawLine(\n+                                p1.x + laneDivision, \n+                                p1.y, \n+                                p2.x + nextLaneDivision, \n+                                p2.y, \n+                                fade * 0.7\n+                            );\n+                        }\n+                        \n+                        // Vertical grid lines\n+                        for (let j = -4; j <= 4; j += 2) {\n+                            const gridX = p1.x + (width1 / 4) * j;\n+                            drawLine(\n+                                gridX,\n+                                p1.y,\n+                                gridX,\n+                                p1.y - 30 * p1.scale,\n+                                fade * 0.5\n+                            );\n+                        }\n+                    }\n                 }\n \n-                // Draw roadside trees\n+                // Draw roadside trees and structures\n                 for (let tree of trees) {\n                     const treePoint = { world: tree, screen: {} };\n-                    project(treePoint, 0, cameraHeight, cameraZ);\n+                    project(treePoint, 0, cameraHeight + bounceOffset, cameraZ);\n+                    \n                     if (treePoint.screen.scale > 0) {\n                         const x = treePoint.screen.x;\n                         const y = treePoint.screen.y;\n-                        const height = 500 * treePoint.screen.scale; // Tree height scales with distance\n-                        drawLine(x, y, x, y - height, treePoint.screen.scale * 0.5); // Fade with distance\n+                        const distanceFade = Math.min(1, treePoint.screen.scale * 0.5);\n+                        \n+                        if (tree.isStructure) {\n+                            // Draw tower/structure\n+                            const height = tree.height * treePoint.screen.scale;\n+                            drawLine(x, y, x, y - height, distanceFade * 0.8);\n+                            \n+                            // Draw cross beams\n+                            const beamWidth = 300 * treePoint.screen.scale;\n+                            const beamCount = 3;\n+                            for (let i = 1; i <= beamCount; i++) {\n+                                const beamY = y - (height * i / (beamCount + 1));\n+                                drawLine(\n+                                    x - beamWidth, \n+                                    beamY, \n+                                    x + beamWidth, \n+                                    beamY, \n+                                    distanceFade * 0.8\n+                                );\n+                            }\n+                            \n+                            // Draw antenna on top\n+                            drawLine(\n+                                x, \n+                                y - height, \n+                                x, \n+                                y - height - (200 * treePoint.screen.scale), \n+                                distanceFade * 0.7\n+                            );\n+                        } else {\n+                            // Draw normal tree\n+                            const height = 500 * treePoint.screen.scale;\n+                            drawLine(x, y, x, y - height, distanceFade);\n+                            \n+                            // Add simple branches\n+                            const branchSize = 150 * treePoint.screen.scale;\n+                            const branchY = y - height * 0.7;\n+                            drawLine(x, branchY, x - branchSize, branchY - branchSize * 0.5, distanceFade * 0.7);\n+                            drawLine(x, branchY, x + branchSize, branchY - branchSize * 0.5, distanceFade * 0.7);\n+                        }\n                     }\n                 }\n \n                 requestAnimationFrame(render);\n             }\n \n-            render();\n+            requestAnimationFrame(render);\n         })();\n     </script>\n </body>\n </html>\n\\ No newline at end of file\n"
                }
            ],
            "date": 1740658348023,
            "name": "Commit-0",
            "content": "<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Enhanced 3D Wireframe Background</title>\n    <style>\n        * {\n            margin: 0;\n            padding: 0;\n            box-sizing: border-box;\n        }\n        body {\n            min-height: 100vh;\n            background-color: #1a1c1f;\n            color: #ffffff;\n            padding: 20px;\n        }\n        #backgroundCanvas {\n            position: fixed;\n            top: 0;\n            left: 0;\n            width: 100%;\n            height: 100%;\n            z-index: -1;\n            opacity: 0.2; /* Subtle background */\n        }\n    </style>\n</head>\n<body>\n    <canvas id=\"backgroundCanvas\"></canvas>\n\n    <script>\n        (function() {\n            const canvas = document.getElementById('backgroundCanvas');\n            const ctx = canvas.getContext('2d');\n\n            // Resize canvas to fit window\n            function resizeCanvas() {\n                canvas.width = window.innerWidth;\n                canvas.height = window.innerHeight;\n            }\n            window.addEventListener('resize', resizeCanvas);\n            resizeCanvas();\n\n            // Configuration\n            const segmentLength = 100;     // Length of each road segment\n            const roadWidth = 2000;        // Width in world units\n            const segmentCount = 200;      // Number of segments\n            const cameraHeight = 1000;     // Camera height above road\n            const cameraDepth = 0.84;      // Perspective factor\n            const fov = 100;               // Field of view\n            let cameraZ = 0;               // Camera position along Z-axis\n            const segments = [];\n\n            // Generate road segments with curves and hills\n            for (let i = 0; i < segmentCount; i++) {\n                segments.push({\n                    index: i,\n                    p1: { world: { x: 0, y: 0, z: i * segmentLength }, screen: {} },\n                    p2: { world: { x: 0, y: 0, z: (i + 1) * segmentLength }, screen: {} },\n                    curve: Math.sin(i / 20) * 1200, // Smooth horizontal curves\n                    hill: Math.cos(i / 30) * 600    // Smooth vertical hills\n                });\n            }\n\n            // Project 3D point to 2D screen coordinates\n            function project(point, camX, camY, camZ) {\n                const dx = point.world.x - camX;\n                const dy = point.world.y - camY;\n                const dz = point.world.z - camZ;\n                const scale = fov / (dz > 0 ? dz : 0.001); // Prevent division by zero\n                point.screen.x = canvas.width / 2 + scale * dx;\n                point.screen.y = canvas.height / 2 - scale * dy;\n                point.screen.scale = scale;\n            }\n\n            // Draw a line with optional alpha for fading\n            function drawLine(x1, y1, x2, y2, alpha = 1) {\n                ctx.globalAlpha = alpha;\n                ctx.beginPath();\n                ctx.moveTo(x1, y1);\n                ctx.lineTo(x2, y2);\n                ctx.stroke();\n            }\n\n            // Render the scene\n            function render() {\n                ctx.clearRect(0, 0, canvas.width, canvas.height);\n\n                // Horizon gradient for depth\n                const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);\n                gradient.addColorStop(0, '#2a2d34');\n                gradient.addColorStop(0.5, '#1a1c1f');\n                ctx.fillStyle = gradient;\n                ctx.fillRect(0, 0, canvas.width, canvas.height);\n\n                ctx.strokeStyle = '#5865F2'; // Retro-inspired color\n                ctx.lineWidth = 1;\n\n                // Move camera forward\n                cameraZ += 150; // Speed of movement\n                if (cameraZ >= segmentCount * segmentLength) {\n                    cameraZ -= segmentCount * segmentLength;\n                }\n\n                const baseSegmentIdx = Math.floor(cameraZ / segmentLength) % segmentCount;\n\n                // Draw segments from back to front\n                for (let i = segmentCount - 1; i >= 0; i--) {\n                    const segment = segments[(baseSegmentIdx + i) % segmentCount];\n                    const nextSegment = segments[(segment.index + 1) % segmentCount];\n\n                    // Apply curves and hills\n                    segment.p1.world.x = segment.curve;\n                    segment.p1.world.y = segment.hill;\n                    segment.p2.world.x = nextSegment.curve;\n                    segment.p2.world.y = nextSegment.hill;\n\n                    // Project points to screen\n                    project(segment.p1, 0, cameraHeight, cameraZ);\n                    project(segment.p2, 0, cameraHeight, cameraZ);\n\n                    // Skip segments behind camera\n                    if (segment.p1.screen.scale <= 0) continue;\n\n                    const p1 = segment.p1.screen;\n                    const p2 = segment.p2.screen;\n                    const fade = Math.min(1, p1.scale * 2); // Fade distant lines\n\n                    // Calculate road edges\n                    const width1 = (roadWidth / 2) * p1.scale;\n                    const width2 = (roadWidth / 2) * p2.scale;\n\n                    // Draw road edges\n                    drawLine(p1.x - width1, p1.y, p2.x - width2, p2.y, fade);\n                    drawLine(p1.x + width1, p1.y, p2.x + width2, p2.y, fade);\n\n                    // Draw grid lines\n                    if (i % 4 === 0) {\n                        // Horizontal grid across road\n                        drawLine(p1.x - width1, p1.y, p1.x + width1, p1.y, fade);\n\n                        // Vertical grid lines (converging)\n                        for (let j = -4; j <= 4; j++) {\n                            const offset = j * (roadWidth / 8);\n                            const gridX1 = p1.x + offset * p1.scale;\n                            const gridX2 = p2.x + offset * p2.scale;\n                            drawLine(gridX1, p1.y, gridX2, p2.y, fade);\n                        }\n                    }\n                }\n\n                requestAnimationFrame(render);\n            }\n\n            render();\n        })();\n    </script>\n</body>\n</html>"
        }
    ]
}