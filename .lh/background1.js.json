{
    "sourceFile": "background1.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1740681886965,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1740681886965,
            "name": "Commit-0",
            "content": "// background.js\ndocument.addEventListener('DOMContentLoaded', function() {\n    (function() {\n        // Get canvas and context\n        const canvas = document.getElementById('backgroundCanvas');\n        if (!canvas) {\n            console.error('Canvas element not found');\n            return;\n        }\n        const ctx = canvas.getContext('2d');\n\n        // Resize canvas to fit window\n        function resizeCanvas() {\n            canvas.width = window.innerWidth;\n            canvas.height = window.innerHeight;\n        }\n        window.addEventListener('resize', resizeCanvas);\n        resizeCanvas();\n\n        // Configuration constants\n        const segmentLength = 100;\n        const roadWidth = 2000;\n        const segmentCount = 400;\n        const cameraHeight = 1000;\n        const fov = 100;\n        const visibleDistance = 20000;\n        let cameraZ = 0;\n        const segments = [];\n\n        // Speed control\n        const baseSpeed = 3000; // units per second\n        const variation = 500;  // units per second\n        let lastTime = 0;\n\n        // Procedural generation functions\n        function hash(z) {\n            return Math.sin(z * 12.9898) * 43758.5453;\n        }\n\n        function shouldPlaceTree(z) {\n            return (hash(z) % 1) > 0.7;\n        }\n\n        function getTreeHeight(z) {\n            return 400 + ((hash(z + 1000) % 1) - 0.5) * 200;\n        }\n\n        // Generate road segments with curves and hills\n        for (let i = 0; i < segmentCount; i++) {\n            const t = (i / segmentCount) * 2 * Math.PI;\n            const noise = Math.sin(t * 5) * 200;\n            segments.push({\n                index: i,\n                p1: { world: { x: 0, y: 0, z: i * segmentLength }, screen: {} },\n                p2: { world: { x: 0, y: 0, z: (i + 1) * segmentLength }, screen: {} },\n                curve: Math.sin(t) * 1200 + noise,\n                hill: Math.cos(t) * 600 + noise * 0.5\n            });\n        }\n\n        // Project 3D points to 2D screen coordinates\n        function project(point, camX, camY, camZ) {\n            const dx = point.world.x - camX;\n            const dy = point.world.y - camY;\n            const dz = point.world.z - camZ;\n            const scale = fov / (dz > 0 ? dz : 0.001);\n            point.screen.x = canvas.width / 2 + scale * dx;\n            point.screen.y = canvas.height / 2 - scale * dy;\n            point.screen.scale = scale;\n        }\n\n        // Draw a line with specified opacity\n        function drawLine(x1, y1, x2, y2, alpha = 1) {\n            ctx.globalAlpha = alpha;\n            ctx.beginPath();\n            ctx.moveTo(x1, y1);\n            ctx.lineTo(x2, y2);\n            ctx.stroke();\n        }\n\n        // Render the scene\n        function render(timestamp) {\n            if (lastTime === 0) lastTime = timestamp;\n            const deltaTime = (timestamp - lastTime) / 1000;\n            lastTime = timestamp;\n            const speed = baseSpeed + Math.sin(timestamp * 0.001) * variation;\n            cameraZ += speed * deltaTime;\n            if (cameraZ >= segmentCount * segmentLength) {\n                cameraZ -= segmentCount * segmentLength;\n            }\n\n            // Clear canvas and draw gradient background\n            ctx.clearRect(0, 0, canvas.width, canvas.height);\n            const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);\n            gradient.addColorStop(0, '#2a2d34');\n            gradient.addColorStop(0.5, '#1a1c1f');\n            ctx.fillStyle = gradient;\n            ctx.fillRect(0, 0, canvas.width, canvas.height);\n\n            ctx.strokeStyle = '#5865F2';\n            ctx.lineWidth = 1;\n\n            // Set shadow for road lines\n            ctx.shadowColor = 'rgba(88, 101, 242, 0.5)';\n            ctx.shadowBlur = 5;\n\n            const baseSegmentIdx = Math.floor(cameraZ / segmentLength) % segmentCount;\n\n            // Draw road segments back to front\n            for (let i = segmentCount - 1; i >= 0; i--) {\n                const idx = (baseSegmentIdx + i) % segmentCount;\n                const segment = segments[idx];\n                const nextSegment = segments[(segment.index + 1) % segmentCount];\n\n                segment.p1.world.x = segment.curve;\n                segment.p1.world.y = segment.hill;\n                segment.p2.world.x = nextSegment.curve;\n                segment.p2.world.y = nextSegment.hill;\n\n                project(segment.p1, 0, cameraHeight, cameraZ);\n                project(segment.p2, 0, cameraHeight, cameraZ);\n\n                if (segment.p1.screen.scale <= 0) continue;\n\n                const p1 = segment.p1.screen;\n                const p2 = segment.p2.screen;\n                const fade = 1; // Full opacity\n\n                const width1 = (roadWidth / 2) * p1.scale;\n                const width2 = (roadWidth / 2) * p2.scale;\n\n                drawLine(p1.x - width1, p1.y, p2.x - width2, p2.y, fade); // Left edge\n                drawLine(p1.x + width1, p1.y, p2.x + width2, p2.y, fade); // Right edge\n\n                const midZ = (segment.p1.world.z + segment.p2.world.z) / 2;\n                if (Math.floor(midZ / 200) % 2 === 0) {\n                    drawLine(p1.x, p1.y, p2.x, p2.y, fade); // Center line\n                }\n            }\n\n            // Reset shadow for trees\n            ctx.shadowBlur = 0;\n\n            // Draw trees\n            const startZ = Math.floor(cameraZ / 100) * 100;\n            const endZ = cameraZ + visibleDistance;\n            for (let z = startZ; z < endZ; z += 100) {\n                const segmentIdx = Math.floor(z / segmentLength) % segmentCount;\n                const segment = segments[segmentIdx];\n                const curve = segment.curve;\n\n                if (shouldPlaceTree(z)) {\n                    const treeBase = { world: { x: curve - roadWidth * 1.5, y: 0, z: z }, screen: {} };\n                    const treeTop = { world: { x: treeBase.world.x, y: getTreeHeight(z), z: z }, screen: {} };\n                    project(treeBase, 0, cameraHeight, cameraZ);\n                    project(treeTop, 0, cameraHeight, cameraZ);\n                    if (treeBase.screen.scale > 0) {\n                        drawLine(treeBase.screen.x, treeBase.screen.y, treeTop.screen.x, treeTop.screen.y, 1);\n                    }\n                }\n                if (shouldPlaceTree(z + 500)) {\n                    const treeBase = { world: { x: curve + roadWidth * 1.5, y: 0, z: z }, screen: {} };\n                    const treeTop = { world: { x: treeBase.world.x, y: getTreeHeight(z + 500), z: z }, screen: {} };\n                    project(treeBase, 0, cameraHeight, cameraZ);\n                    project(treeTop, 0, cameraHeight, cameraZ);\n                    if (treeBase.screen.scale > 0) {\n                        drawLine(treeBase.screen.x, treeBase.screen.y, treeTop.screen.x, treeTop.screen.y, 1);\n                    }\n                }\n            }\n\n            // Continue animation loop\n            requestAnimationFrame(render);\n        }\n\n        // Start the animation\n        requestAnimationFrame(render);\n    })();\n});"
        }
    ]
}