{
    "sourceFile": "background_og.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1740745972123,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1740745972123,
            "name": "Commit-0",
            "content": "document.addEventListener('DOMContentLoaded', function() {\n    const isDarkMode = () => {\n        const isDarkReader = document.documentElement.classList.contains('darkreader') || \n                             document.querySelector('.darkreader') !== null;\n        const isPrefersColorScheme = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;\n        return isDarkReader || isPrefersColorScheme;\n    };\n\n    const colors = {\n        light: {\n            sky: ['#121417', '#1e2228', '#1a1c1f', '#161719'],\n            ground: '#080809',\n            road: '#4f59c9',\n            mountain: '#3b4152',\n            tree: {\n                trunk: '#5D6378',\n                foliage: ['#4C5268', '#546078', '#505D75']\n            }\n        },\n        dark: {\n            sky: ['#121417', '#1e2228', '#1a1c1f', '#161719'],\n            ground: '#080809',\n            road: '#3b407b',\n            mountain: '#4e5a79',\n            tree: {\n                trunk: '#4D5368',\n                foliage: ['#3C4258', '#445068', '#404D65']\n            }\n        }\n    };\n\n    (function() {\n        // **Setup Canvas and Context**\n        const canvas = document.getElementById('backgroundCanvas');\n        if (!canvas) {\n            console.error('Canvas element not found');\n            return;\n        }\n        const ctx = canvas.getContext('2d');\n\n        // **Resize Canvas to Fit Window**\n        function resizeCanvas() {\n            canvas.width = window.innerWidth;\n            canvas.height = window.innerHeight;\n        }\n        window.addEventListener('resize', resizeCanvas);\n        resizeCanvas();\n\n        // **Configuration Constants**\n        const segmentLength = 100;\n        const roadWidth = 2000;\n        const segmentCount = 600;\n        const cacheSegmentCount = 1000;\n        const baseCameraHeight = 1000;\n        const fov = 100;\n        const visibleDistance = 20000;\n        let cameraZ = 0;\n        let totalDistance = 0;\n        const segments = [];\n\n        // **Mouse Controls**\n        let mouseY = 0;\n        let targetDistance = 1.0;\n        let currentDistance = 1.0;\n        const distanceSmoothness = 0.05;\n        const minDistance = 0.6;\n        const maxDistance = 1.5;\n\n        document.addEventListener('mousemove', function(event) {\n            mouseY = (event.clientY / window.innerHeight) * 2 - 1;\n            targetDistance = minDistance + ((1 - mouseY) / 2) * (maxDistance - minDistance);\n        });\n\n        // **Speed Control**\n        const baseSpeed = 3000;\n        const variation = 500;\n        let lastTime = 0;\n\n        // **Fibonacci Sequence and Golden Ratio**\n        const goldenRatio = 1.61803398875;\n        const fibSequence = [1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144];\n\n        // **Perlin-like Noise Functions**\n        class PerlinNoise {\n            constructor(seed = Math.random()) {\n                this.seed = seed;\n                this.gradients = {};\n                this.memory = {};\n            }\n            rand_vect() {\n                let theta = Math.random() * 2 * Math.PI;\n                return {x: Math.cos(theta), y: Math.sin(theta)};\n            }\n            dot_prod_grid(x, y, vx, vy) {\n                let g_vect;\n                let d_vect = {x: x - vx, y: y - vy};\n                if (this.gradients[[vx,vy]]) {\n                    g_vect = this.gradients[[vx,vy]];\n                } else {\n                    g_vect = this.rand_vect();\n                    this.gradients[[vx, vy]] = g_vect;\n                }\n                return d_vect.x * g_vect.x + d_vect.y * g_vect.y;\n            }\n            smootherstep(x) {\n                return 6*x**5 - 15*x**4 + 10*x**3;\n            }\n            interp(x, a, b) {\n                return a + this.smootherstep(x) * (b-a);\n            }\n            get(x, y) {\n                const key = JSON.stringify([x, y]);\n                if (this.memory.hasOwnProperty(key)) \n                    return this.memory[key];\n                let xf = Math.floor(x);\n                let yf = Math.floor(y);\n                let tl = this.dot_prod_grid(x, y, xf, yf);\n                let tr = this.dot_prod_grid(x, y, xf+1, yf);\n                let bl = this.dot_prod_grid(x, y, xf, yf+1);\n                let br = this.dot_prod_grid(x, y, xf+1, yf+1);\n                let xt = this.interp(x-xf, tl, tr);\n                let xb = this.interp(x-xf, bl, br);\n                let v = this.interp(y-yf, xt, xb);\n                this.memory[[x,y]] = v;\n                return v;\n            }\n        }\n\n        const curveNoise = new PerlinNoise(42);\n        const hillNoise = new PerlinNoise(17);\n        const treeNoise = new PerlinNoise(33);\n\n        function naturalNoise(z, noiseObj, scale, octaves) {\n            let value = 0;\n            let amplitude = 1;\n            let frequency = 1;\n            let max = 0;\n            for(let i = 0; i < octaves; i++) {\n                value += amplitude * noiseObj.get(z * frequency / scale, 0.5);\n                max += amplitude;\n                amplitude *= 0.5;\n                frequency *= 2;\n            }\n            return value / max;\n        }\n\n        function generateNaturalCurve(z) {\n            // Increase scale from 10000 to 20000 to stretch out curves\n            let baseNoise = naturalNoise(z, curveNoise, 20000, 3);\n            \n            // Reduce number of harmonics for smoother curves\n            let harmonics = 0;\n            // Only use first 5 Fibonacci values instead of all of them\n            for(let i = 0; i < 5; i++) {\n                // Lower frequency for longer curves\n                let freq = fibSequence[i] / 200; // Reduced from /100 to /200\n                let amp = fibSequence[fibSequence.length - i - 1] / 89;\n                harmonics += Math.sin(z * freq / 1000) * amp;\n            }\n            \n            // Add a persistence factor to maintain curve direction\n            const persistenceFactor = Math.sin(z / 20000) * 1500;\n            \n            // Reduce overall amplitude of harmonics (800 -> 500)\n            return baseNoise * 3000 + harmonics * 500 + persistenceFactor;\n        }\n\n        function generateNaturalHill(z) {\n            let baseNoise = naturalNoise(z, hillNoise, 15000, 4);\n            let harmonics = 0;\n            for(let i = 1; i < 5; i++) {\n                let freq = Math.pow(goldenRatio, i) / 10;\n                let amp = 1 / Math.pow(goldenRatio, i);\n                harmonics += Math.sin(z * freq / 1000 + i) * amp;\n            }\n            return baseNoise * 800 + harmonics * 400;\n        }\n\n        function generateSegment(z) {\n            return {\n                z: z,\n                curve: generateNaturalCurve(z),\n                hill: generateNaturalHill(z)\n            };\n        }\n\n        for (let i = 0; i < segmentCount; i++) {\n            const z = i * segmentLength;\n            const segData = generateSegment(z);\n            segments.push({\n                index: i,\n                p1: { world: { x: 0, y: 0, z: z }, screen: {} },\n                p2: { world: { x: 0, y: 0, z: (i + 1) * segmentLength }, screen: {} },\n                curve: segData.curve,\n                hill: segData.hill\n            });\n        }\n\n        // Update the shouldPlaceTree function to be more sparse\n        function shouldPlaceTree(z) {\n            // Use a more sophisticated hash function for better distribution\n            const hashValue = Math.sin(z * 12.9898 + 4.1414) * 43758.5453;\n            // Higher threshold (0.95) for much sparser trees\n            return (hashValue % 1) > 0.95;\n        }\n\n        // Enhance tree height function to create more variety\n        function getTreeHeight(z) {\n            // Base height plus more variation\n            return 300 + Math.abs(naturalNoise(z, treeNoise, 5000, 2) * 500);\n        }\n\n        // Add tree variety function\n        function getTreeType(z) {\n            const type = Math.floor((Math.sin(z * 0.3) * 0.5 + 0.5) * 3);\n            return type; // 0, 1, or 2 for different tree types\n        }\n\n        // Update the drawTree function to support multiple tree types\n        function drawTree(base, top, scale, alpha, treeType = 0) {\n            // Draw trunk - brighter color\n            ctx.strokeStyle = colors[isDarkMode() ? 'dark' : 'light'].tree.trunk;\n            ctx.lineWidth = 2 * scale;\n            drawLine(base.screen.x, base.screen.y, top.screen.x, top.screen.y, alpha);\n            \n            // Different tree types with brighter colors\n            const branchLength = 60 * scale;\n            \n            switch(treeType) {\n                case 0: // Pine tree - brighter\n                    ctx.strokeStyle = colors[isDarkMode() ? 'dark' : 'light'].tree.foliage[0];\n                    ctx.lineWidth = 1 * scale;\n                    // Draw triangular canopy\n                    const levels = 3;\n                    for (let i = 0; i < levels; i++) {\n                        const heightRatio = 0.5 + (i * 0.2);\n                        const width = branchLength * (1 - i/levels);\n                        const y = base.screen.y - (top.screen.y - base.screen.y) * heightRatio;\n                        drawLine(top.screen.x - width, y, top.screen.x + width, y, alpha * 0.8);\n                        drawLine(top.screen.x, y - width * 0.5, top.screen.x - width, y, alpha * 0.8);\n                        drawLine(top.screen.x, y - width * 0.5, top.screen.x + width, y, alpha * 0.8);\n                    }\n                    break;\n                    \n                case 1: // Rounded tree - brighter\n                    ctx.strokeStyle = colors[isDarkMode() ? 'dark' : 'light'].tree.foliage[1];\n                    ctx.lineWidth = 1 * scale;\n                    // Add branches in a more rounded pattern\n                    for (let i = 0; i < 5; i++) {\n                        const angle = (i / 5) * Math.PI;\n                        const branchX = top.screen.x + branchLength * Math.cos(angle);\n                        const branchY = top.screen.y - branchLength * Math.sin(angle);\n                        drawLine(top.screen.x, top.screen.y, branchX, branchY, alpha * 0.7);\n                    }\n                    break;\n                    \n                case 2: // Simple tree - brighter\n                    ctx.strokeStyle = colors[isDarkMode() ? 'dark' : 'light'].tree.foliage[2];\n                    ctx.lineWidth = 1 * scale;\n                    // Simple Y-shaped branches\n                    const branchAngle = Math.PI / 5;\n                    const branchX1 = top.screen.x + branchLength * Math.cos(branchAngle);\n                    const branchY1 = top.screen.y - branchLength * Math.sin(branchAngle);\n                    const branchX2 = top.screen.x + branchLength * Math.cos(-branchAngle);\n                    const branchY2 = top.screen.y - branchLength * Math.sin(-branchAngle);\n                    drawLine(top.screen.x, top.screen.y, branchX1, branchY1, alpha * 0.7);\n                    drawLine(top.screen.x, top.screen.y, branchX2, branchY2, alpha * 0.7);\n                    break;\n            }\n        }\n\n        function project(point, camX, camY, camZ) {\n            const dx = point.world.x - camX;\n            const dy = point.world.y - camY;\n            const dz = point.world.z - camZ;\n            if (dz <= 0) return false;\n            const distanceFromCenter = Math.sqrt(dx * dx + dy * dy);\n            const correction = 1.0 + (distanceFromCenter / 5000) * 0.15;\n            const scale = (fov / dz) * correction;\n            point.screen.x = canvas.width / 2 + scale * dx;\n            point.screen.y = canvas.height / 2 - scale * dy;\n            point.screen.scale = scale;\n            return true;\n        }\n\n        // Add this function to calculate brightness based on distance\n        function calculateBrightness(z) {\n            // Calculate normalized distance (0 = close, 1 = far)\n            const normalizedDist = Math.min(z / visibleDistance, 1);\n            \n            // Inverse the value and add more dramatic falloff\n            // Objects close to camera (small z) will have brightness near 1\n            // Objects far away will have brightness approaching 0.3\n            return 1 - (normalizedDist * 0.7);\n        }\n\n        // Modify the drawLine function to use brightness factor\n        function drawLine(p1x, p1y, p2x, p2y, alpha = 1) {\n            // Preserve original alpha for distance-based calculation\n            ctx.globalAlpha = alpha;\n            ctx.beginPath();\n            ctx.moveTo(p1x, p1y);\n            ctx.lineTo(p2x, p2y);\n            ctx.stroke();\n            ctx.globalAlpha = 1;\n        }\n\n        // In your render/drawing loop, update how you draw segments\n        function renderSegment(segment) {\n            // ... existing code ...\n            \n            // Calculate brightness based on segment distance\n            const brightness = calculateBrightness(segment.z);\n            \n            // Use brightness to adjust stroke colors\n            const r = Math.round(91 * brightness); // For road: 5B65D2 (91, 101, 210)\n            const g = Math.round(101 * brightness);\n            const b = Math.round(210 * brightness);\n            \n            ctx.strokeStyle = `rgb(${r},${g},${b})`;\n            \n            // Apply brightness to alpha value for line drawing\n            const adjustedAlpha = fade * brightness * 1.3; // Multiply by 1.3 to make close objects extra bright\n            \n            // Draw with adjusted brightness\n            drawLine(p1.x, p1.y, p2.x, p2.y, adjustedAlpha);\n            \n            // For tree rendering, also use brightness factor\n            // ... in tree drawing code ...\n            const treeBrightness = calculateBrightness(treeSegment.z);\n            ctx.strokeStyle = `rgb(${Math.round(108 * treeBrightness)},${Math.round(114 * treeBrightness)},${Math.round(136 * treeBrightness)})`;\n        }\n\n        // Render loop\n        function render(timestamp) {\n            if (lastTime === 0) lastTime = timestamp;\n            const deltaTime = (timestamp - lastTime) / 1000;\n            lastTime = timestamp;\n\n            const speed = baseSpeed + Math.sin(timestamp * 0.001) * variation;\n            cameraZ += speed * deltaTime;\n            totalDistance += speed * deltaTime;\n\n            const maxZ = Math.max(...segments.map(s => s.p2.world.z));\n            if (cameraZ + visibleDistance > maxZ - 2000) {\n                const nextZ = maxZ;\n                const segData = generateSegment(nextZ);\n                segments.push({\n                    index: segments.length,\n                    p1: { world: { x: 0, y: 0, z: nextZ }, screen: {} },\n                    p2: { world: { x: 0, y: 0, z: nextZ + segmentLength }, screen: {} },\n                    curve: segData.curve,\n                    hill: segData.hill\n                });\n                if (segments.length > cacheSegmentCount) {\n                    segments.shift();\n                    segments.forEach((seg, idx) => seg.index = idx);\n                }\n            }\n\n            currentDistance += (targetDistance - currentDistance) * distanceSmoothness;\n            const currentCameraY = baseCameraHeight * (1 - (currentDistance - 1.0) * 0.3);\n\n            // Calculate average position of upcoming road segments to center camera\n            const lookAheadDistance = 5000; // How far ahead to look for centering\n            const visibleCurveSegments = segments.filter(seg => \n                seg.p1.world.z >= cameraZ && \n                seg.p1.world.z < cameraZ + lookAheadDistance\n            );\n            \n            // Default to 0 if no segments found\n            let averageCurve = 0;\n            if (visibleCurveSegments.length > 0) {\n                averageCurve = visibleCurveSegments.reduce((sum, seg) => sum + seg.curve, 0) / \n                               visibleCurveSegments.length;\n            }\n            \n            // Use this average curve as camera X position\n            const currentCameraX = averageCurve;\n\n            ctx.clearRect(0, 0, canvas.width, canvas.height);\n            const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);\n            gradient.addColorStop(0, '#242a36');\n            gradient.addColorStop(0.4, '#131519');\n            gradient.addColorStop(0.7, '#080809');\n            gradient.addColorStop(1, '#000000');\n            ctx.fillStyle = gradient;\n            ctx.fillRect(0, 0, canvas.width, canvas.height);\n\n            ctx.strokeStyle = '#7B86FF'; // Brighter blue for road lines\n            ctx.lineWidth = 1.5; // Increased from 1 to 1.5 for more visibility\n\n            const minZ = cameraZ;\n            const maxVisibleZ = cameraZ + visibleDistance;\n            const visibleSegments = segments.filter(seg => \n                seg.p2.world.z > minZ && seg.p1.world.z < maxVisibleZ\n            ).sort((a, b) => b.p1.world.z - a.p1.world.z);\n\n            for (const segment of visibleSegments) {\n                const nextIdx = segment.index + 1;\n                if (nextIdx >= segments.length) continue;\n                const nextSegment = segments[nextIdx];\n                segment.p1.world.x = segment.curve;\n                segment.p1.world.y = segment.hill;\n                segment.p2.world.x = nextSegment.curve;\n                segment.p2.world.y = nextSegment.hill;\n                const projected1 = project(segment.p1, currentCameraX, currentCameraY, cameraZ);\n                const projected2 = project(segment.p2, currentCameraX, currentCameraY, cameraZ);\n                if (!projected1 || !projected2) continue;\n                const p1 = segment.p1.screen;\n                const p2 = segment.p2.screen;\n                const distanceRatio = (segment.p1.world.z - cameraZ) / visibleDistance;\n                const fade = Math.min(1, 1 - distanceRatio * distanceRatio);\n                const width1 = (roadWidth / 2) * p1.scale;\n                const width2 = (roadWidth / 2) * p2.scale;\n                drawLine(p1.x - width1, p1.y, p2.x - width2, p2.y, fade);\n                drawLine(p1.x + width1, p1.y, p2.x + width2, p2.y, fade);\n                const midZ = segment.p1.world.z;\n                const fibMod = Math.floor(midZ / 100) % fibSequence.length;\n                if (fibMod < 3 || fibMod > 8) {\n                    ctx.strokeStyle = '#A3ADFF'; // Brighter center line\n                    drawLine(p1.x, p1.y, p2.x, p2.y, fade * 0.9); // Increased from 0.8 to 0.9\n                    // Remember to reset stroke style after\n                    ctx.strokeStyle = '#7B86FF';\n                }\n            }\n\n            const startZ = Math.floor(cameraZ / 100) * 100;\n            const endZ = cameraZ + visibleDistance;\n\n            function findSegmentByZ(z) {\n                for (let i = 0; i < segments.length - 1; i++) {\n                    if (segments[i].p1.world.z <= z && segments[i+1].p1.world.z > z) {\n                        return i;\n                    }\n                }\n                return Math.floor((z - segments[0].p1.world.z) / segmentLength);\n            }\n\n            // **Modified: Draw trees with branches and depth**\n            for (let z = startZ; z < endZ; z += 100) {\n                const segmentIdx = findSegmentByZ(z);\n                if (segmentIdx < 0 || segmentIdx >= segments.length - 1) continue;\n                const segment = segments[segmentIdx];\n                const nextSegment = segments[segmentIdx + 1];\n                const segStartZ = segment.p1.world.z;\n                const segEndZ = nextSegment.p1.world.z;\n                const t = (z - segStartZ) / (segEndZ - segStartZ);\n                const curve = segment.curve * (1 - t) + nextSegment.curve * t;\n\n                // Tree on the left\n                if (shouldPlaceTree(z)) {\n                    const treeBase = { world: { x: curve - roadWidth * 1.5, y: 0, z: z }, screen: {} };\n                    const treeTop = { world: { x: treeBase.world.x, y: getTreeHeight(z), z: z }, screen: {} };\n                    const projectedBase = project(treeBase, currentCameraX, currentCameraY, cameraZ);\n                    const projectedTop = project(treeTop, currentCameraX, currentCameraY, cameraZ);\n                    if (projectedBase && projectedTop) {\n                        const distanceRatio = (z - cameraZ) / visibleDistance;\n                        const opacity = Math.max(0, 1 - distanceRatio * 1.2);\n                        const scale = projectedBase.scale;\n                        drawTree(treeBase, treeTop, scale, opacity, getTreeType(z));\n                    }\n                }\n\n                // Tree on the right\n                if (shouldPlaceTree(z + 500)) {\n                    // Add an additional random offset for more natural placement\n                    const lateralOffset = (Math.sin(z * 0.03) * 0.5 + 0.5) * 500;\n                    const treeBase = { world: { x: curve + roadWidth * 1.5 + lateralOffset, y: 0, z: z }, screen: {} };\n                    const treeTop = { world: { x: treeBase.world.x, y: getTreeHeight(z + 500), z: z }, screen: {} };\n                    const projectedBase = project(treeBase, currentCameraX, currentCameraY, cameraZ);\n                    const projectedTop = project(treeTop, currentCameraX, currentCameraY, cameraZ);\n                    if (projectedBase && projectedTop) {\n                        const distanceRatio = (z - cameraZ) / visibleDistance;\n                        const opacity = Math.max(0, 1 - distanceRatio * 1.2);\n                        const scale = projectedBase.scale;\n                        drawTree(treeBase, treeTop, scale, opacity, getTreeType(z + 300));\n                    }\n                }\n\n                // Add occasional forest clusters for more visual interest\n                if (shouldPlaceTree(z * 1.7)) {\n                    for (let i = 0; i < 3; i++) {\n                        const offset = (i - 1) * 150;\n                        const treeBase = { world: { x: curve - roadWidth * 3 + offset, y: 0, z: z + offset }, screen: {} };\n                        const treeTop = { world: { x: treeBase.world.x, y: getTreeHeight(z + i * 200) * 0.8, z: z + offset }, screen: {} };\n                        const projectedBase = project(treeBase, currentCameraX, currentCameraY, cameraZ);\n                        const projectedTop = project(treeTop, currentCameraX, currentCameraY, cameraZ);\n                        if (projectedBase && projectedTop) {\n                            const distanceRatio = (z - cameraZ) / visibleDistance;\n                            const opacity = Math.max(0, 1 - distanceRatio * 1.2) * 0.7;\n                            const scale = projectedBase.scale * 0.8;\n                            drawTree(treeBase, treeTop, scale, opacity, getTreeType(z + i * 100));\n                        }\n                    }\n                }\n            }\n\n            requestAnimationFrame(render);\n        }\n\n        // **Start Animation**\n        requestAnimationFrame(render);\n    })();\n});"
        }
    ]
}