{
    "sourceFile": "background.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 4,
            "patches": [
                {
                    "date": 1740666532889,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1740668604162,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,137 @@\n+document.addEventListener('DOMContentLoaded', function() {\n+    (function() {\n+        const canvas = document.getElementById('backgroundCanvas');\n+        if (!canvas) return;\n+        const ctx = canvas.getContext('2d');\n+\n+        // Resize canvas to fit window\n+        function resizeCanvas() {\n+            canvas.width = window.innerWidth;\n+            canvas.height = window.innerHeight;\n+        }\n+        window.addEventListener('resize', resizeCanvas);\n+        resizeCanvas();\n+\n+        // Configuration\n+        const segmentLength = 100;        // Length of each road segment\n+        const roadWidth = 2000;           // Width of the road\n+        const cameraHeight = 1000;        // Camera height above road\n+        const fov = 100;                  // Field of view for projection\n+        const visibleDistance = 20000;    // Distance ahead to render\n+        const bufferDistance = 5000;      // Distance behind to keep segments\n+        let cameraZ = 0;                  // Camera's Z-position\n+        const segments = [];              // Dynamic array of road segments\n+\n+        // Speed control\n+        const baseSpeed = 3000;           // Base movement speed (units/sec)\n+        const variation = 500;            // Speed variation (units/sec)\n+        let lastTime = 0;                 // Timestamp for delta time\n+\n+        // Procedural generation functions\n+        function getCurve(z) {\n+            return Math.sin(z / 500) * 1200 + Math.sin(z / 200) * 200;\n+        }\n+\n+        function getHill(z) {\n+            return Math.cos(z / 600) * 600 + Math.cos(z / 250) * 150;\n+        }\n+\n+        // Generate segments between startZ and endZ\n+        function generateSegments(startZ, endZ) {\n+            for (let z = startZ; z < endZ; z += segmentLength) {\n+                const t = z / segmentLength;\n+                segments.push({\n+                    index: t,\n+                    p1: { world: { x: getCurve(z), y: getHill(z), z: z }, screen: {} },\n+                    p2: { world: { x: getCurve(z + segmentLength), y: getHill(z + segmentLength), z: z + segmentLength }, screen: {} }\n+                });\n+            }\n+        }\n+\n+        // Initial segment generation\n+        generateSegments(0, visibleDistance);\n+\n+        // Project 3D world coordinates to 2D screen\n+        function project(point, camX, camY, camZ) {\n+            const dx = point.world.x - camX;\n+            const dy = point.world.y - camY;\n+            const dz = point.world.z - camZ;\n+            const scale = fov / (dz > 0 ? dz : 0.001); // Avoid division by zero\n+            point.screen.x = canvas.width / 2 + scale * dx;\n+            point.screen.y = canvas.height / 2 - scale * dy;\n+            point.screen.scale = scale;\n+        }\n+\n+        // Draw a line on the canvas\n+        function drawLine(x1, y1, x2, y2, alpha = 1) {\n+            ctx.globalAlpha = alpha;\n+            ctx.beginPath();\n+            ctx.moveTo(x1, y1);\n+            ctx.lineTo(x2, y2);\n+            ctx.stroke();\n+        }\n+\n+        // Render the scene\n+        function render(timestamp) {\n+            if (lastTime === 0) lastTime = timestamp;\n+            const deltaTime = (timestamp - lastTime) / 1000; // Time in seconds\n+            lastTime = timestamp;\n+\n+            // Update camera position with variable speed\n+            const speed = baseSpeed + Math.sin(timestamp * 0.001) * variation;\n+            cameraZ += speed * deltaTime;\n+\n+            // Manage segments dynamically\n+            const minZ = cameraZ - bufferDistance;\n+            const maxZ = cameraZ + visibleDistance;\n+            while (segments.length && segments[0].p1.world.z < minZ) {\n+                segments.shift(); // Remove segments far behind\n+            }\n+            const lastSegmentZ = segments[segments.length - 1].p2.world.z;\n+            if (lastSegmentZ < maxZ) {\n+                generateSegments(lastSegmentZ, maxZ); // Add new segments ahead\n+            }\n+\n+            // Clear and set background\n+            ctx.clearRect(0, 0, canvas.width, canvas.height);\n+            const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);\n+            gradient.addColorStop(0, '#2a2d34');\n+            gradient.addColorStop(0.5, '#1a1c1f');\n+            ctx.fillStyle = gradient;\n+            ctx.fillRect(0, 0, canvas.width, canvas.height);\n+\n+            // Set drawing styles\n+            ctx.strokeStyle = '#5865F2';\n+            ctx.lineWidth = 1;\n+            ctx.shadowColor = 'rgba(88, 101, 242, 0.5)';\n+            ctx.shadowBlur = 5;\n+\n+            // Draw road segments\n+            for (let i = segments.length - 1; i >= 0; i--) {\n+                const segment = segments[i];\n+                project(segment.p1, 0, cameraHeight, cameraZ);\n+                project(segment.p2, 0, cameraHeight, cameraZ);\n+                if (segment.p1.screen.scale <= 0) continue; // Skip if behind camera\n+\n+                const p1 = segment.p1.screen;\n+                const p2 = segment.p2.screen;\n+                const width1 = (roadWidth / 2) * p1.scale;\n+                const width2 = (roadWidth / 2) * p2.scale;\n+\n+                drawLine(p1.x - width1, p1.y, p2.x - width2, p2.y); // Left edge\n+                drawLine(p1.x + width1, p1.y, p2.x + width2, p2.y); // Right edge\n+\n+                const midZ = (segment.p1.world.z + segment.p2.world.z) / 2;\n+                if (Math.floor(midZ / 200) % 2 === 0) {\n+                    drawLine(p1.x, p1.y, p2.x, p2.y); // Center line\n+                }\n+            }\n+\n+            ctx.shadowBlur = 0; // Reset shadow\n+            requestAnimationFrame(render); // Continue animation\n+        }\n+\n+        // Start the animation\n+        requestAnimationFrame(render);\n+    })();\n+});\n\\ No newline at end of file\n"
                },
                {
                    "date": 1740668628176,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,141 +1,4 @@\n-document.addEventListener('DOMContentLoaded', function() {\n-    (function() {\n-        const canvas = document.getElementById('backgroundCanvas');\n-        if (!canvas) return;\n-        const ctx = canvas.getContext('2d');\n-\n-        // Resize canvas to fit window\n-        function resizeCanvas() {\n-            canvas.width = window.innerWidth;\n-            canvas.height = window.innerHeight;\n-        }\n-        window.addEventListener('resize', resizeCanvas);\n-        resizeCanvas();\n-\n-        // Configuration\n-        const segmentLength = 100;        // Length of each road segment\n-        const roadWidth = 2000;           // Width of the road\n-        const cameraHeight = 1000;        // Camera height above road\n-        const fov = 100;                  // Field of view for projection\n-        const visibleDistance = 20000;    // Distance ahead to render\n-        const bufferDistance = 5000;      // Distance behind to keep segments\n-        let cameraZ = 0;                  // Camera's Z-position\n-        const segments = [];              // Dynamic array of road segments\n-\n-        // Speed control\n-        const baseSpeed = 3000;           // Base movement speed (units/sec)\n-        const variation = 500;            // Speed variation (units/sec)\n-        let lastTime = 0;                 // Timestamp for delta time\n-\n-        // Procedural generation functions\n-        function getCurve(z) {\n-            return Math.sin(z / 500) * 1200 + Math.sin(z / 200) * 200;\n-        }\n-\n-        function getHill(z) {\n-            return Math.cos(z / 600) * 600 + Math.cos(z / 250) * 150;\n-        }\n-\n-        // Generate segments between startZ and endZ\n-        function generateSegments(startZ, endZ) {\n-            for (let z = startZ; z < endZ; z += segmentLength) {\n-                const t = z / segmentLength;\n-                segments.push({\n-                    index: t,\n-                    p1: { world: { x: getCurve(z), y: getHill(z), z: z }, screen: {} },\n-                    p2: { world: { x: getCurve(z + segmentLength), y: getHill(z + segmentLength), z: z + segmentLength }, screen: {} }\n-                });\n-            }\n-        }\n-\n-        // Initial segment generation\n-        generateSegments(0, visibleDistance);\n-\n-        // Project 3D world coordinates to 2D screen\n-        function project(point, camX, camY, camZ) {\n-            const dx = point.world.x - camX;\n-            const dy = point.world.y - camY;\n-            const dz = point.world.z - camZ;\n-            const scale = fov / (dz > 0 ? dz : 0.001); // Avoid division by zero\n-            point.screen.x = canvas.width / 2 + scale * dx;\n-            point.screen.y = canvas.height / 2 - scale * dy;\n-            point.screen.scale = scale;\n-        }\n-\n-        // Draw a line on the canvas\n-        function drawLine(x1, y1, x2, y2, alpha = 1) {\n-            ctx.globalAlpha = alpha;\n-            ctx.beginPath();\n-            ctx.moveTo(x1, y1);\n-            ctx.lineTo(x2, y2);\n-            ctx.stroke();\n-        }\n-\n-        // Render the scene\n-        function render(timestamp) {\n-            if (lastTime === 0) lastTime = timestamp;\n-            const deltaTime = (timestamp - lastTime) / 1000; // Time in seconds\n-            lastTime = timestamp;\n-\n-            // Update camera position with variable speed\n-            const speed = baseSpeed + Math.sin(timestamp * 0.001) * variation;\n-            cameraZ += speed * deltaTime;\n-\n-            // Manage segments dynamically\n-            const minZ = cameraZ - bufferDistance;\n-            const maxZ = cameraZ + visibleDistance;\n-            while (segments.length && segments[0].p1.world.z < minZ) {\n-                segments.shift(); // Remove segments far behind\n-            }\n-            const lastSegmentZ = segments[segments.length - 1].p2.world.z;\n-            if (lastSegmentZ < maxZ) {\n-                generateSegments(lastSegmentZ, maxZ); // Add new segments ahead\n-            }\n-\n-            // Clear and set background\n-            ctx.clearRect(0, 0, canvas.width, canvas.height);\n-            const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);\n-            gradient.addColorStop(0, '#2a2d34');\n-            gradient.addColorStop(0.5, '#1a1c1f');\n-            ctx.fillStyle = gradient;\n-            ctx.fillRect(0, 0, canvas.width, canvas.height);\n-\n-            // Set drawing styles\n-            ctx.strokeStyle = '#5865F2';\n-            ctx.lineWidth = 1;\n-            ctx.shadowColor = 'rgba(88, 101, 242, 0.5)';\n-            ctx.shadowBlur = 5;\n-\n-            // Draw road segments\n-            for (let i = segments.length - 1; i >= 0; i--) {\n-                const segment = segments[i];\n-                project(segment.p1, 0, cameraHeight, cameraZ);\n-                project(segment.p2, 0, cameraHeight, cameraZ);\n-                if (segment.p1.screen.scale <= 0) continue; // Skip if behind camera\n-\n-                const p1 = segment.p1.screen;\n-                const p2 = segment.p2.screen;\n-                const width1 = (roadWidth / 2) * p1.scale;\n-                const width2 = (roadWidth / 2) * p2.scale;\n-\n-                drawLine(p1.x - width1, p1.y, p2.x - width2, p2.y); // Left edge\n-                drawLine(p1.x + width1, p1.y, p2.x + width2, p2.y); // Right edge\n-\n-                const midZ = (segment.p1.world.z + segment.p2.world.z) / 2;\n-                if (Math.floor(midZ / 200) % 2 === 0) {\n-                    drawLine(p1.x, p1.y, p2.x, p2.y); // Center line\n-                }\n-            }\n-\n-            ctx.shadowBlur = 0; // Reset shadow\n-            requestAnimationFrame(render); // Continue animation\n-        }\n-\n-        // Start the animation\n-        requestAnimationFrame(render);\n-    })();\n-});\n // background.js\n document.addEventListener('DOMContentLoaded', function() {\n     (function() {\n         // Get canvas and context\n"
                },
                {
                    "date": 1740668914250,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -19,19 +19,17 @@\n \n         // Configuration constants\n         const segmentLength = 100;\n         const roadWidth = 2000;\n-        const segmentCount = 400;\n         const cameraHeight = 1000;\n         const fov = 100;\n         const visibleDistance = 20000;\n+        const bufferDistance = 5000; // Extra segments ahead\n         let cameraZ = 0;\n-        const segments = [];\n-\n-        // Speed control\n+        let segments = [];\n+        let lastTime = 0;\n         const baseSpeed = 3000; // units per second\n         const variation = 500;  // units per second\n-        let lastTime = 0;\n \n         // Procedural generation functions\n         function hash(z) {\n             return Math.sin(z * 12.9898) * 43758.5453;\n@@ -44,21 +42,34 @@\n         function getTreeHeight(z) {\n             return 400 + ((hash(z + 1000) % 1) - 0.5) * 200;\n         }\n \n-        // Generate road segments with curves and hills\n-        for (let i = 0; i < segmentCount; i++) {\n-            const t = (i / segmentCount) * 2 * Math.PI;\n-            const noise = Math.sin(t * 5) * 200;\n-            segments.push({\n-                index: i,\n-                p1: { world: { x: 0, y: 0, z: i * segmentLength }, screen: {} },\n-                p2: { world: { x: 0, y: 0, z: (i + 1) * segmentLength }, screen: {} },\n-                curve: Math.sin(t) * 1200 + noise,\n-                hill: Math.cos(t) * 600 + noise * 0.5\n-            });\n+        // Procedural road properties based on Z-position\n+        function getCurve(z) {\n+            const t = z / 1000; // Scale for smoothness\n+            return Math.sin(t) * 1200 + Math.sin(t * 5) * 200;\n         }\n \n+        function getHill(z) {\n+            const t = z / 1000;\n+            return Math.cos(t) * 600 + Math.sin(t * 5) * 100;\n+        }\n+\n+        // Generate segments for a given Z range\n+        function generateSegments(startZ, endZ) {\n+            const newSegments = [];\n+            for (let z = startZ; z < endZ; z += segmentLength) {\n+                newSegments.push({\n+                    p1: { world: { x: getCurve(z), y: getHill(z), z: z }, screen: {} },\n+                    p2: { world: { x: getCurve(z + segmentLength), y: getHill(z + segmentLength), z: z + segmentLength }, screen: {} }\n+                });\n+            }\n+            return newSegments;\n+        }\n+\n+        // Initialize segments\n+        segments = generateSegments(0, visibleDistance + bufferDistance);\n+\n         // Project 3D points to 2D screen coordinates\n         function project(point, camX, camY, camZ) {\n             const dx = point.world.x - camX;\n             const dy = point.world.y - camY;\n@@ -84,10 +95,16 @@\n             const deltaTime = (timestamp - lastTime) / 1000;\n             lastTime = timestamp;\n             const speed = baseSpeed + Math.sin(timestamp * 0.001) * variation;\n             cameraZ += speed * deltaTime;\n-            if (cameraZ >= segmentCount * segmentLength) {\n-                cameraZ -= segmentCount * segmentLength;\n+\n+            // Update segments dynamically\n+            if (cameraZ > segments[0].p1.world.z + visibleDistance) {\n+                const newStartZ = segments[segments.length - 1].p2.world.z;\n+                const newEndZ = newStartZ + visibleDistance + bufferDistance;\n+                const newSegments = generateSegments(newStartZ, newEndZ);\n+                segments = segments.filter(seg => seg.p2.world.z > cameraZ - segmentLength);\n+                segments.push(...newSegments);\n             }\n \n             // Clear canvas and draw gradient background\n             ctx.clearRect(0, 0, canvas.width, canvas.height);\n@@ -103,25 +120,15 @@\n             // Set shadow for road lines\n             ctx.shadowColor = 'rgba(88, 101, 242, 0.5)';\n             ctx.shadowBlur = 5;\n \n-            const baseSegmentIdx = Math.floor(cameraZ / segmentLength) % segmentCount;\n-\n             // Draw road segments back to front\n-            for (let i = segmentCount - 1; i >= 0; i--) {\n-                const idx = (baseSegmentIdx + i) % segmentCount;\n-                const segment = segments[idx];\n-                const nextSegment = segments[(segment.index + 1) % segmentCount];\n-\n-                segment.p1.world.x = segment.curve;\n-                segment.p1.world.y = segment.hill;\n-                segment.p2.world.x = nextSegment.curve;\n-                segment.p2.world.y = nextSegment.hill;\n-\n+            for (let i = segments.length - 1; i >= 0; i--) {\n+                const segment = segments[i];\n                 project(segment.p1, 0, cameraHeight, cameraZ);\n                 project(segment.p2, 0, cameraHeight, cameraZ);\n \n-                if (segment.p1.screen.scale <= 0) continue;\n+                if (segment.p1.screen.scale <= 0 || segment.p2.screen.scale <= 0) continue;\n \n                 const p1 = segment.p1.screen;\n                 const p2 = segment.p2.screen;\n                 const fade = 1; // Full opacity\n@@ -144,23 +151,19 @@\n             // Draw trees\n             const startZ = Math.floor(cameraZ / 100) * 100;\n             const endZ = cameraZ + visibleDistance;\n             for (let z = startZ; z < endZ; z += 100) {\n-                const segmentIdx = Math.floor(z / segmentLength) % segmentCount;\n-                const segment = segments[segmentIdx];\n-                const curve = segment.curve;\n-\n                 if (shouldPlaceTree(z)) {\n-                    const treeBase = { world: { x: curve - roadWidth * 1.5, y: 0, z: z }, screen: {} };\n+                    const treeBase = { world: { x: getCurve(z) - roadWidth * 1.5, y: 0, z: z }, screen: {} };\n                     const treeTop = { world: { x: treeBase.world.x, y: getTreeHeight(z), z: z }, screen: {} };\n                     project(treeBase, 0, cameraHeight, cameraZ);\n                     project(treeTop, 0, cameraHeight, cameraZ);\n                     if (treeBase.screen.scale > 0) {\n                         drawLine(treeBase.screen.x, treeBase.screen.y, treeTop.screen.x, treeTop.screen.y, 1);\n                     }\n                 }\n                 if (shouldPlaceTree(z + 500)) {\n-                    const treeBase = { world: { x: curve + roadWidth * 1.5, y: 0, z: z }, screen: {} };\n+                    const treeBase = { world: { x: getCurve(z) + roadWidth * 1.5, y: 0, z: z }, screen: {} };\n                     const treeTop = { world: { x: treeBase.world.x, y: getTreeHeight(z + 500), z: z }, screen: {} };\n                     project(treeBase, 0, cameraHeight, cameraZ);\n                     project(treeTop, 0, cameraHeight, cameraZ);\n                     if (treeBase.screen.scale > 0) {\n"
                },
                {
                    "date": 1740668932064,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -19,17 +19,19 @@\n \n         // Configuration constants\n         const segmentLength = 100;\n         const roadWidth = 2000;\n+        const segmentCount = 400;\n         const cameraHeight = 1000;\n         const fov = 100;\n         const visibleDistance = 20000;\n-        const bufferDistance = 5000; // Extra segments ahead\n         let cameraZ = 0;\n-        let segments = [];\n-        let lastTime = 0;\n+        const segments = [];\n+\n+        // Speed control\n         const baseSpeed = 3000; // units per second\n         const variation = 500;  // units per second\n+        let lastTime = 0;\n \n         // Procedural generation functions\n         function hash(z) {\n             return Math.sin(z * 12.9898) * 43758.5453;\n@@ -42,34 +44,21 @@\n         function getTreeHeight(z) {\n             return 400 + ((hash(z + 1000) % 1) - 0.5) * 200;\n         }\n \n-        // Procedural road properties based on Z-position\n-        function getCurve(z) {\n-            const t = z / 1000; // Scale for smoothness\n-            return Math.sin(t) * 1200 + Math.sin(t * 5) * 200;\n+        // Generate road segments with curves and hills\n+        for (let i = 0; i < segmentCount; i++) {\n+            const t = (i / segmentCount) * 2 * Math.PI;\n+            const noise = Math.sin(t * 5) * 200;\n+            segments.push({\n+                index: i,\n+                p1: { world: { x: 0, y: 0, z: i * segmentLength }, screen: {} },\n+                p2: { world: { x: 0, y: 0, z: (i + 1) * segmentLength }, screen: {} },\n+                curve: Math.sin(t) * 1200 + noise,\n+                hill: Math.cos(t) * 600 + noise * 0.5\n+            });\n         }\n \n-        function getHill(z) {\n-            const t = z / 1000;\n-            return Math.cos(t) * 600 + Math.sin(t * 5) * 100;\n-        }\n-\n-        // Generate segments for a given Z range\n-        function generateSegments(startZ, endZ) {\n-            const newSegments = [];\n-            for (let z = startZ; z < endZ; z += segmentLength) {\n-                newSegments.push({\n-                    p1: { world: { x: getCurve(z), y: getHill(z), z: z }, screen: {} },\n-                    p2: { world: { x: getCurve(z + segmentLength), y: getHill(z + segmentLength), z: z + segmentLength }, screen: {} }\n-                });\n-            }\n-            return newSegments;\n-        }\n-\n-        // Initialize segments\n-        segments = generateSegments(0, visibleDistance + bufferDistance);\n-\n         // Project 3D points to 2D screen coordinates\n         function project(point, camX, camY, camZ) {\n             const dx = point.world.x - camX;\n             const dy = point.world.y - camY;\n@@ -95,16 +84,10 @@\n             const deltaTime = (timestamp - lastTime) / 1000;\n             lastTime = timestamp;\n             const speed = baseSpeed + Math.sin(timestamp * 0.001) * variation;\n             cameraZ += speed * deltaTime;\n-\n-            // Update segments dynamically\n-            if (cameraZ > segments[0].p1.world.z + visibleDistance) {\n-                const newStartZ = segments[segments.length - 1].p2.world.z;\n-                const newEndZ = newStartZ + visibleDistance + bufferDistance;\n-                const newSegments = generateSegments(newStartZ, newEndZ);\n-                segments = segments.filter(seg => seg.p2.world.z > cameraZ - segmentLength);\n-                segments.push(...newSegments);\n+            if (cameraZ >= segmentCount * segmentLength) {\n+                cameraZ -= segmentCount * segmentLength;\n             }\n \n             // Clear canvas and draw gradient background\n             ctx.clearRect(0, 0, canvas.width, canvas.height);\n@@ -120,15 +103,25 @@\n             // Set shadow for road lines\n             ctx.shadowColor = 'rgba(88, 101, 242, 0.5)';\n             ctx.shadowBlur = 5;\n \n+            const baseSegmentIdx = Math.floor(cameraZ / segmentLength) % segmentCount;\n+\n             // Draw road segments back to front\n-            for (let i = segments.length - 1; i >= 0; i--) {\n-                const segment = segments[i];\n+            for (let i = segmentCount - 1; i >= 0; i--) {\n+                const idx = (baseSegmentIdx + i) % segmentCount;\n+                const segment = segments[idx];\n+                const nextSegment = segments[(segment.index + 1) % segmentCount];\n+\n+                segment.p1.world.x = segment.curve;\n+                segment.p1.world.y = segment.hill;\n+                segment.p2.world.x = nextSegment.curve;\n+                segment.p2.world.y = nextSegment.hill;\n+\n                 project(segment.p1, 0, cameraHeight, cameraZ);\n                 project(segment.p2, 0, cameraHeight, cameraZ);\n \n-                if (segment.p1.screen.scale <= 0 || segment.p2.screen.scale <= 0) continue;\n+                if (segment.p1.screen.scale <= 0) continue;\n \n                 const p1 = segment.p1.screen;\n                 const p2 = segment.p2.screen;\n                 const fade = 1; // Full opacity\n@@ -151,19 +144,23 @@\n             // Draw trees\n             const startZ = Math.floor(cameraZ / 100) * 100;\n             const endZ = cameraZ + visibleDistance;\n             for (let z = startZ; z < endZ; z += 100) {\n+                const segmentIdx = Math.floor(z / segmentLength) % segmentCount;\n+                const segment = segments[segmentIdx];\n+                const curve = segment.curve;\n+\n                 if (shouldPlaceTree(z)) {\n-                    const treeBase = { world: { x: getCurve(z) - roadWidth * 1.5, y: 0, z: z }, screen: {} };\n+                    const treeBase = { world: { x: curve - roadWidth * 1.5, y: 0, z: z }, screen: {} };\n                     const treeTop = { world: { x: treeBase.world.x, y: getTreeHeight(z), z: z }, screen: {} };\n                     project(treeBase, 0, cameraHeight, cameraZ);\n                     project(treeTop, 0, cameraHeight, cameraZ);\n                     if (treeBase.screen.scale > 0) {\n                         drawLine(treeBase.screen.x, treeBase.screen.y, treeTop.screen.x, treeTop.screen.y, 1);\n                     }\n                 }\n                 if (shouldPlaceTree(z + 500)) {\n-                    const treeBase = { world: { x: getCurve(z) + roadWidth * 1.5, y: 0, z: z }, screen: {} };\n+                    const treeBase = { world: { x: curve + roadWidth * 1.5, y: 0, z: z }, screen: {} };\n                     const treeTop = { world: { x: treeBase.world.x, y: getTreeHeight(z + 500), z: z }, screen: {} };\n                     project(treeBase, 0, cameraHeight, cameraZ);\n                     project(treeTop, 0, cameraHeight, cameraZ);\n                     if (treeBase.screen.scale > 0) {\n"
                }
            ],
            "date": 1740666532889,
            "name": "Commit-0",
            "content": "// background.js\ndocument.addEventListener('DOMContentLoaded', function() {\n    (function() {\n        // Get canvas and context\n        const canvas = document.getElementById('backgroundCanvas');\n        if (!canvas) {\n            console.error('Canvas element not found');\n            return;\n        }\n        const ctx = canvas.getContext('2d');\n\n        // Resize canvas to fit window\n        function resizeCanvas() {\n            canvas.width = window.innerWidth;\n            canvas.height = window.innerHeight;\n        }\n        window.addEventListener('resize', resizeCanvas);\n        resizeCanvas();\n\n        // Configuration constants\n        const segmentLength = 100;\n        const roadWidth = 2000;\n        const segmentCount = 400;\n        const cameraHeight = 1000;\n        const fov = 100;\n        const visibleDistance = 20000;\n        let cameraZ = 0;\n        const segments = [];\n\n        // Speed control\n        const baseSpeed = 3000; // units per second\n        const variation = 500;  // units per second\n        let lastTime = 0;\n\n        // Procedural generation functions\n        function hash(z) {\n            return Math.sin(z * 12.9898) * 43758.5453;\n        }\n\n        function shouldPlaceTree(z) {\n            return (hash(z) % 1) > 0.7;\n        }\n\n        function getTreeHeight(z) {\n            return 400 + ((hash(z + 1000) % 1) - 0.5) * 200;\n        }\n\n        // Generate road segments with curves and hills\n        for (let i = 0; i < segmentCount; i++) {\n            const t = (i / segmentCount) * 2 * Math.PI;\n            const noise = Math.sin(t * 5) * 200;\n            segments.push({\n                index: i,\n                p1: { world: { x: 0, y: 0, z: i * segmentLength }, screen: {} },\n                p2: { world: { x: 0, y: 0, z: (i + 1) * segmentLength }, screen: {} },\n                curve: Math.sin(t) * 1200 + noise,\n                hill: Math.cos(t) * 600 + noise * 0.5\n            });\n        }\n\n        // Project 3D points to 2D screen coordinates\n        function project(point, camX, camY, camZ) {\n            const dx = point.world.x - camX;\n            const dy = point.world.y - camY;\n            const dz = point.world.z - camZ;\n            const scale = fov / (dz > 0 ? dz : 0.001);\n            point.screen.x = canvas.width / 2 + scale * dx;\n            point.screen.y = canvas.height / 2 - scale * dy;\n            point.screen.scale = scale;\n        }\n\n        // Draw a line with specified opacity\n        function drawLine(x1, y1, x2, y2, alpha = 1) {\n            ctx.globalAlpha = alpha;\n            ctx.beginPath();\n            ctx.moveTo(x1, y1);\n            ctx.lineTo(x2, y2);\n            ctx.stroke();\n        }\n\n        // Render the scene\n        function render(timestamp) {\n            if (lastTime === 0) lastTime = timestamp;\n            const deltaTime = (timestamp - lastTime) / 1000;\n            lastTime = timestamp;\n            const speed = baseSpeed + Math.sin(timestamp * 0.001) * variation;\n            cameraZ += speed * deltaTime;\n            if (cameraZ >= segmentCount * segmentLength) {\n                cameraZ -= segmentCount * segmentLength;\n            }\n\n            // Clear canvas and draw gradient background\n            ctx.clearRect(0, 0, canvas.width, canvas.height);\n            const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);\n            gradient.addColorStop(0, '#2a2d34');\n            gradient.addColorStop(0.5, '#1a1c1f');\n            ctx.fillStyle = gradient;\n            ctx.fillRect(0, 0, canvas.width, canvas.height);\n\n            ctx.strokeStyle = '#5865F2';\n            ctx.lineWidth = 1;\n\n            // Set shadow for road lines\n            ctx.shadowColor = 'rgba(88, 101, 242, 0.5)';\n            ctx.shadowBlur = 5;\n\n            const baseSegmentIdx = Math.floor(cameraZ / segmentLength) % segmentCount;\n\n            // Draw road segments back to front\n            for (let i = segmentCount - 1; i >= 0; i--) {\n                const idx = (baseSegmentIdx + i) % segmentCount;\n                const segment = segments[idx];\n                const nextSegment = segments[(segment.index + 1) % segmentCount];\n\n                segment.p1.world.x = segment.curve;\n                segment.p1.world.y = segment.hill;\n                segment.p2.world.x = nextSegment.curve;\n                segment.p2.world.y = nextSegment.hill;\n\n                project(segment.p1, 0, cameraHeight, cameraZ);\n                project(segment.p2, 0, cameraHeight, cameraZ);\n\n                if (segment.p1.screen.scale <= 0) continue;\n\n                const p1 = segment.p1.screen;\n                const p2 = segment.p2.screen;\n                const fade = 1; // Full opacity\n\n                const width1 = (roadWidth / 2) * p1.scale;\n                const width2 = (roadWidth / 2) * p2.scale;\n\n                drawLine(p1.x - width1, p1.y, p2.x - width2, p2.y, fade); // Left edge\n                drawLine(p1.x + width1, p1.y, p2.x + width2, p2.y, fade); // Right edge\n\n                const midZ = (segment.p1.world.z + segment.p2.world.z) / 2;\n                if (Math.floor(midZ / 200) % 2 === 0) {\n                    drawLine(p1.x, p1.y, p2.x, p2.y, fade); // Center line\n                }\n            }\n\n            // Reset shadow for trees\n            ctx.shadowBlur = 0;\n\n            // Draw trees\n            const startZ = Math.floor(cameraZ / 100) * 100;\n            const endZ = cameraZ + visibleDistance;\n            for (let z = startZ; z < endZ; z += 100) {\n                const segmentIdx = Math.floor(z / segmentLength) % segmentCount;\n                const segment = segments[segmentIdx];\n                const curve = segment.curve;\n\n                if (shouldPlaceTree(z)) {\n                    const treeBase = { world: { x: curve - roadWidth * 1.5, y: 0, z: z }, screen: {} };\n                    const treeTop = { world: { x: treeBase.world.x, y: getTreeHeight(z), z: z }, screen: {} };\n                    project(treeBase, 0, cameraHeight, cameraZ);\n                    project(treeTop, 0, cameraHeight, cameraZ);\n                    if (treeBase.screen.scale > 0) {\n                        drawLine(treeBase.screen.x, treeBase.screen.y, treeTop.screen.x, treeTop.screen.y, 1);\n                    }\n                }\n                if (shouldPlaceTree(z + 500)) {\n                    const treeBase = { world: { x: curve + roadWidth * 1.5, y: 0, z: z }, screen: {} };\n                    const treeTop = { world: { x: treeBase.world.x, y: getTreeHeight(z + 500), z: z }, screen: {} };\n                    project(treeBase, 0, cameraHeight, cameraZ);\n                    project(treeTop, 0, cameraHeight, cameraZ);\n                    if (treeBase.screen.scale > 0) {\n                        drawLine(treeBase.screen.x, treeBase.screen.y, treeTop.screen.x, treeTop.screen.y, 1);\n                    }\n                }\n            }\n\n            // Continue animation loop\n            requestAnimationFrame(render);\n        }\n\n        // Start the animation\n        requestAnimationFrame(render);\n    })();\n});"
        }
    ]
}