package main

import (
	"database/sql"
	"fmt"
	"log"
	"strings"

	_ "github.com/lib/pq"
)

func main() {
	// Database connection details
	connStr := "host=localhost port=5432 user=postgres password=postgres dbname=bikenode sslmode=disable"
	
	// Connect to database
	db, err := sql.Open("postgres", connStr)
	if err != nil {
		log.Fatal("Failed to connect to database:", err)
	}
	defer db.Close()

	// Test connection
	err = db.Ping()
	if err != nil {
		log.Fatal("Failed to ping database:", err)
	}
	
	fmt.Println("Successfully connected to PostgreSQL database!")
	fmt.Println(strings.Repeat("=", 50))

	// 1. Get total counts
	fmt.Println("\n1. TOTAL COUNTS:")
	fmt.Println(strings.Repeat("-", 30))
	
	var bikeCount, manufacturerCount, familyCount int
	
	err = db.QueryRow("SELECT COUNT(*) FROM bikes").Scan(&bikeCount)
	if err != nil {
		log.Printf("Error counting bikes: %v", err)
	}
	
	err = db.QueryRow("SELECT COUNT(*) FROM manufacturers").Scan(&manufacturerCount)
	if err != nil {
		log.Printf("Error counting manufacturers: %v", err)
	}
	
	err = db.QueryRow("SELECT COUNT(*) FROM bike_families").Scan(&familyCount)
	if err != nil {
		log.Printf("Error counting families: %v", err)
	}
	
	fmt.Printf("Total bikes: %d\n", bikeCount)
	fmt.Printf("Total manufacturers: %d\n", manufacturerCount)
	fmt.Printf("Total bike families: %d\n", familyCount)

	// 2. List manufacturers with bike counts
	fmt.Println("\n2. MANUFACTURERS WITH BIKE COUNTS:")
	fmt.Println(strings.Repeat("-", 30))
	
	rows, err := db.Query(`
		SELECT m.id, m.name, COUNT(b.id) as bike_count
		FROM manufacturers m
		LEFT JOIN bikes b ON m.id = b.manufacturer_id
		GROUP BY m.id, m.name
		ORDER BY bike_count DESC, m.name
		LIMIT 20
	`)
	if err != nil {
		log.Printf("Error querying manufacturers: %v", err)
	} else {
		defer rows.Close()
		
		for rows.Next() {
			var id int
			var name string
			var count int
			
			err := rows.Scan(&id, &name, &count)
			if err != nil {
				log.Printf("Error scanning row: %v", err)
				continue
			}
			
			fmt.Printf("ID: %3d | %-30s | Bikes: %d\n", id, name, count)
		}
	}

	// 3. Sample bikes with manufacturer and family info
	fmt.Println("\n3. SAMPLE BIKES WITH DETAILS:")
	fmt.Println(strings.Repeat("-", 30))
	
	bikeRows, err := db.Query(`
		SELECT 
			b.id,
			b.model,
			m.name as manufacturer,
			bf.family_name as family,
			b.year,
			b.msrp
		FROM bikes b
		JOIN manufacturers m ON b.manufacturer_id = m.id
		LEFT JOIN bike_families bf ON b.family_id = bf.id
		ORDER BY b.id
		LIMIT 10
	`)
	if err != nil {
		log.Printf("Error querying bikes: %v", err)
	} else {
		defer bikeRows.Close()
		
		fmt.Printf("%-5s | %-40s | %-20s | %-20s | %-4s | %s\n", 
			"ID", "Model", "Manufacturer", "Family", "Year", "MSRP")
		fmt.Println(strings.Repeat("-", 120))
		
		for bikeRows.Next() {
			var id int
			var model, manufacturer string
			var family sql.NullString
			var year sql.NullInt32
			var msrp sql.NullInt32
			
			err := bikeRows.Scan(&id, &model, &manufacturer, &family, &year, &msrp)
			if err != nil {
				log.Printf("Error scanning bike row: %v", err)
				continue
			}
			
			familyStr := "N/A"
			if family.Valid {
				familyStr = family.String
			}
			
			yearStr := "N/A"
			if year.Valid {
				yearStr = fmt.Sprintf("%d", year.Int32)
			}
			
			msrpStr := "N/A"
			if msrp.Valid {
				msrpStr = fmt.Sprintf("$%d", msrp.Int32)
			}
			
			fmt.Printf("%-5d | %-40s | %-20s | %-20s | %-4s | %s\n", 
				id, model, manufacturer, familyStr, yearStr, msrpStr)
		}
	}

	// 4. Check for any bikes without manufacturers (data integrity)
	fmt.Println("\n4. DATA INTEGRITY CHECK:")
	fmt.Println(strings.Repeat("-", 30))
	
	var orphanCount int
	err = db.QueryRow("SELECT COUNT(*) FROM bikes WHERE manufacturer_id IS NULL").Scan(&orphanCount)
	if err != nil {
		log.Printf("Error checking orphan bikes: %v", err)
	} else {
		fmt.Printf("Bikes without manufacturer: %d\n", orphanCount)
	}

	// 5. Year distribution
	fmt.Println("\n5. YEAR DISTRIBUTION:")
	fmt.Println(strings.Repeat("-", 30))
	
	yearRows, err := db.Query(`
		SELECT year, COUNT(*) as count
		FROM bikes
		WHERE year IS NOT NULL
		GROUP BY year
		ORDER BY year DESC
		LIMIT 10
	`)
	if err != nil {
		log.Printf("Error querying year distribution: %v", err)
	} else {
		defer yearRows.Close()
		
		for yearRows.Next() {
			var year, count int
			err := yearRows.Scan(&year, &count)
			if err != nil {
				log.Printf("Error scanning year row: %v", err)
				continue
			}
			fmt.Printf("Year %d: %d bikes\n", year, count)
		}
	}

	fmt.Println("\n" + strings.Repeat("=", 50))
	fmt.Println("Verification complete!")
}