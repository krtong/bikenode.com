---
layout: dashboard.njk
title: Route Planner
subtitle: Plan your next motorcycle adventure
---

<div class="route-planner">
    <!-- Route Planning Sidebar -->
    <div class="route-sidebar">
        <div class="route-header">
            <h2>Plan Your Route</h2>
            <div class="route-type-selector">
                <button class="route-type active" data-type="motorcycle">üèçÔ∏è Motorcycle</button>
                <button class="route-type" data-type="bicycle">üö¥ Bicycle</button>
            </div>
        </div>

        <!-- Build Your Route -->
        <div class="build-route-section">
            <h4>Build your route</h4>
            <p class="instruction-text" id="instructionText">Click the map or enter start point</p>
            <div class="start-point-input">
                <input type="text" id="startPointInput" placeholder="Enter start location..." class="form-control">
                <button class="btn-start-here" id="useMyLocation">üìç Use My Location</button>
            </div>
            
            <!-- Waypoint Controls -->
            <div class="waypoint-controls">
                <button class="btn-waypoint" id="addWaypointMode">
                    <span class="waypoint-icon">üìç</span>
                    <span class="waypoint-text">Click to Add Waypoints</span>
                </button>
                <div class="waypoint-help">
                    <small>Click the map to add waypoints, drag to reposition</small>
                </div>
            </div>
        </div>

        <!-- Waypoint List -->
        <div class="waypoint-list-section" id="waypointListSection" style="display: none;">
            <h4>Waypoints</h4>
            <div class="waypoint-list" id="waypointList">
                <!-- Waypoints will be populated here -->
            </div>
        </div>

        <!-- Routing Preferences -->
        <div class="routing-preferences">
            <h4>Routing preferences</h4>
            
            <div class="ride-type-section">
                <label>Ride</label>
                <select id="rideType" class="form-control">
                    <option value="popular">Follow most popular</option>
                    <option value="scenic">Scenic route</option>
                    <option value="direct">Most direct</option>
                    <option value="trails">Bike trails/paths</option>
                </select>
            </div>

            <div class="elevation-preference">
                <label>Elevation <span class="bike-only" style="color: var(--accent); font-size: 0.8em; display: none;">‚úì</span></label>
                <select id="elevationPref" class="form-control">
                    <option value="any">Any elevation</option>
                    <option value="flat">Minimize elevation</option>
                    <option value="hilly">Maximize elevation</option>
                </select>
            </div>

            <div class="surface-preference">
                <label>Surface type <span class="bike-only" style="color: var(--accent); font-size: 0.8em; display: none;">‚úì</span></label>
                <select id="surfacePref" class="form-control">
                    <option value="any">Any surface type</option>
                    <option value="paved">Paved roads only</option>
                    <option value="gravel">Include gravel</option>
                    <option value="trails">Include trails</option>
                </select>
            </div>

            <div class="mode-toggle">
                <label class="toggle-item" title="Limited support: Requires custom routing server">
                    <input type="checkbox" id="avoidHighways">
                    <span class="toggle-slider"></span>
                    Avoid highways <span style="color: var(--text-secondary); font-size: 0.8em;">*</span>
                </label>
                <label class="toggle-item">
                    <input type="checkbox" id="manualMode">
                    <span class="toggle-slider"></span>
                    Manual mode
                </label>
            </div>
            <p style="font-size: 0.75rem; color: var(--text-secondary); margin: 8px 0 0 0; line-height: 1.4;">
                * Highway avoidance requires a custom OSRM server with modified Lua profiles. 
                The public routing server doesn't support this feature.
            </p>
        </div>

        <!-- Map Display Preferences -->
        <div class="map-display-prefs">
            <h4>Map display</h4>
            
            <div class="display-options">
                <label class="toggle-item">
                    <input type="checkbox" id="showSurfaceType" checked>
                    <span class="toggle-slider"></span>
                    Surface type
                </label>
                <label class="toggle-item">
                    <input type="checkbox" id="showDistanceMarkers" checked>
                    <span class="toggle-slider"></span>
                    Distance markers
                </label>
                <label class="toggle-item">
                    <input type="checkbox" id="showHeatmaps">
                    <span class="toggle-slider"></span>
                    Heatmaps (1)
                </label>
                <label class="toggle-item">
                    <input type="checkbox" id="showSegments">
                    <span class="toggle-slider"></span>
                    Segments
                </label>
            </div>
        </div>

        <!-- Route Stats -->
        <div class="route-stats-section">
            <h4>Route path</h4>
            <div class="distance-display">
                <span class="distance-value" id="routeDistance">0</span>
                <span class="distance-unit">mi</span>
                <span class="distance-label">Miles</span>
            </div>
            
            <div class="elevation-display">
                <div class="elevation-item">
                    <span class="elevation-label">Elevation Gain</span>
                    <span class="elevation-value" id="routeElevation">0 ft</span>
                </div>
                <div class="elevation-item">
                    <span class="elevation-label">Elevation Lost</span>
                    <span class="elevation-value" id="elevationLost">0 ft</span>
                </div>
            </div>
        </div>

        <!-- Surface Type Display -->
        <div class="surface-type-section">
            <h4>Surface type</h4>
            <div class="surface-breakdown">
                <div class="surface-item">
                    <span class="surface-color paved"></span>
                    <span>Paved</span>
                    <span class="surface-percent" id="pavedPercent">0%</span>
                </div>
                <div class="surface-item">
                    <span class="surface-color gravel"></span>
                    <span>Gravel</span>
                    <span class="surface-percent" id="gravelPercent">0%</span>
                </div>
                <div class="surface-item">
                    <span class="surface-color dirt"></span>
                    <span>Trail</span>
                    <span class="surface-percent" id="dirtPercent">0%</span>
                </div>
            </div>
        </div>

        <!-- My Routes Section -->
        <div class="my-routes-section">
            <h4>My Routes</h4>
            <div class="route-list" id="savedRoutesList">
                <p class="no-routes">No saved routes yet</p>
            </div>
            <button class="btn-secondary btn-small" id="viewAllRoutes">View all routes</button>
        </div>

        <!-- Action Buttons -->
        <div class="route-actions">
            <button class="btn-primary" id="saveRoute">Save Route</button>
            <div class="secondary-actions">
                <button class="btn-secondary" id="shareRoute">Share</button>
                <button class="btn-secondary" id="exportRoute">Export GPX</button>
                <button class="btn-outline" id="clearRoute">Clear</button>
            </div>
        </div>
    </div>

    <!-- Map Container -->
    <div class="map-container">
        <div class="map-controls">
            <div class="map-style-selector">
                <button class="map-style" data-style="street">Light</button>
                <button class="map-style active" data-style="dark">Dark</button>
                <button class="map-style" data-style="satellite">Satellite</button>
                <button class="map-style" data-style="terrain">Terrain</button>
            </div>
            <div class="map-layers">
                <button class="layer-toggle" data-layer="traffic">üö¶ Traffic</button>
                <button class="layer-toggle active" data-layer="curves">üåÄ Twisty Roads</button>
                <button class="layer-toggle" data-layer="elevation">‚õ∞Ô∏è Elevation</button>
            </div>
        </div>
        
        <!-- Real OpenStreetMap Interface -->
        <div class="map-display" id="routeMap"></div>

        <!-- Elevation Profile -->
        <div class="elevation-profile" id="elevationProfileContainer">
            <div class="profile-header">
                <h4>Elevation Profile</h4>
                <div class="profile-stats" id="elevationStats" style="display: none;">
                    <span>Max: <strong id="elevationMax">-- ft</strong></span>
                    <span>Min: <strong id="elevationMin">-- ft</strong></span>
                    <span>Avg Grade: <strong id="avgGrade">--%</strong></span>
                </div>
            </div>
            <div class="profile-chart" id="profileChartContainer">
                <div class="no-route-message" id="noRouteMessage" style="text-align: center; padding: 40px 20px; color: var(--text-secondary);">
                    <p style="margin: 0; font-size: 0.9rem;">Add waypoints to see elevation profile</p>
                </div>
                <canvas id="elevationChart" width="400" height="120" style="display: none;"></canvas>
                <div class="elevation-tooltip" id="elevationTooltip" style="display: none;">
                    <div class="tooltip-distance">Distance: <span>0 mi</span></div>
                    <div class="tooltip-elevation">Elevation: <span>0 ft</span></div>
                    <div class="tooltip-grade">Grade: <span>0%</span></div>
                </div>
            </div>
            <div class="elevation-legend" id="elevationLegend" style="display: none;">
                <div class="legend-item">
                    <span class="legend-color" style="background: #10b981;"></span>
                    <span>Descent (&lt; -3%)</span>
                </div>
                <div class="legend-item">
                    <span class="legend-color" style="background: #6b7280;"></span>
                    <span>Flat (-3% to 3%)</span>
                </div>
                <div class="legend-item">
                    <span class="legend-color" style="background: #f59e0b;"></span>
                    <span>Moderate (3% to 7%)</span>
                </div>
                <div class="legend-item">
                    <span class="legend-color" style="background: #ef4444;"></span>
                    <span>Steep (&gt; 7%)</span>
                </div>
            </div>
        </div>
    </div>
</div>

<style>
/* Route Planner Styles */
.route-planner {
    display: grid;
    grid-template-columns: 380px 1fr;
    height: 70vh;
    min-height: 600px;
    gap: 0;
    background: var(--bg-primary);
    border-radius: 12px;
    overflow: hidden;
    border: 1px solid rgba(255, 255, 255, 0.1);
    margin: 0;
    width: 100%;
}

/* Sidebar Styles */
.route-sidebar {
    background: var(--card-bg);
    border-right: 1px solid rgba(255, 255, 255, 0.1);
    padding: 24px;
    overflow-y: auto;
    display: flex;
    flex-direction: column;
    gap: 24px;
}

.route-header h2 {
    color: var(--text-primary);
    margin: 0 0 16px 0;
    font-size: 1.5rem;
    font-weight: 700;
}

.route-type-selector {
    display: flex;
    gap: 8px;
}

.route-type {
    flex: 1;
    padding: 8px 12px;
    border: 1px solid rgba(255, 255, 255, 0.2);
    background: transparent;
    color: var(--text-secondary);
    border-radius: 8px;
    font-size: 0.9rem;
    cursor: pointer;
    transition: all 0.2s ease;
}

.route-type.active {
    background: var(--accent);
    color: white;
    border-color: var(--accent);
}

.quick-start {
    margin-bottom: 24px;
}

.btn-start-here {
    width: 100%;
    padding: 10px 16px;
    background: var(--accent);
    color: white;
    border: none;
    border-radius: 6px;
    font-size: 0.9rem;
    font-weight: 500;
    cursor: pointer;
    transition: all 0.2s ease;
}

.btn-start-here:hover {
    background: var(--accent-hover);
    transform: translateY(-1px);
}

.setting-group {
    display: flex;
    flex-direction: column;
    gap: 12px;
}

.setting-group label {
    color: var(--text-primary);
    font-weight: 600;
    font-size: 0.9rem;
}

.form-control {
    padding: 10px 12px;
    background: rgba(255, 255, 255, 0.05);
    border: 1px solid rgba(255, 255, 255, 0.2);
    border-radius: 8px;
    color: var(--text-primary);
    font-size: 0.9rem;
}

.preference-toggles {
    display: flex;
    flex-direction: column;
    gap: 12px;
}

.toggle-item {
    display: flex;
    align-items: center;
    gap: 12px;
    font-size: 0.9rem;
    color: var(--text-secondary);
    cursor: pointer;
}

.toggle-slider {
    width: 40px;
    height: 20px;
    background: rgba(255, 255, 255, 0.2);
    border-radius: 10px;
    position: relative;
    transition: all 0.3s ease;
}

.toggle-slider::after {
    content: '';
    position: absolute;
    width: 16px;
    height: 16px;
    background: white;
    border-radius: 50%;
    top: 2px;
    left: 2px;
    transition: all 0.3s ease;
}

.toggle-item input:checked + .toggle-slider {
    background: var(--accent);
}

.toggle-item input:checked + .toggle-slider::after {
    transform: translateX(20px);
}

.toggle-item input {
    display: none;
}

.loop-controls {
    display: flex;
    gap: 8px;
}

.loop-controls button {
    flex: 1;
    padding: 8px 12px;
    font-size: 0.85rem;
}

.route-stats {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 12px;
}

.stat-item {
    background: rgba(255, 255, 255, 0.05);
    border-radius: 8px;
    padding: 12px;
    display: flex;
    align-items: center;
    gap: 8px;
}

.stat-icon {
    font-size: 1.2rem;
}

.stat-content {
    display: flex;
    flex-direction: column;
}

.stat-value {
    color: var(--text-primary);
    font-weight: 700;
    font-size: 1.1rem;
}

.stat-label {
    color: var(--text-secondary);
    font-size: 0.75rem;
}

.surface-breakdown h4 {
    color: var(--text-primary);
    margin: 0 0 12px 0;
    font-size: 1rem;
}

.surface-item {
    display: flex;
    align-items: center;
    gap: 8px;
    margin-bottom: 8px;
    font-size: 0.9rem;
    color: var(--text-secondary);
}

.surface-color {
    width: 12px;
    height: 12px;
    border-radius: 2px;
}

.surface-color.paved { background: #10b981; }
.surface-color.gravel { background: #f59e0b; }
.surface-color.dirt { background: #8b5cf6; }

.surface-percent {
    margin-left: auto;
    font-weight: 600;
    color: var(--text-primary);
}

.poi-section h4 {
    color: var(--text-primary);
    margin: 0 0 12px 0;
    font-size: 1rem;
}

.poi-buttons {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 8px;
}

.poi-btn {
    padding: 8px 12px;
    background: rgba(255, 255, 255, 0.1);
    border: 1px solid rgba(255, 255, 255, 0.3);
    border-radius: 8px;
    color: #ffffff;
    font-size: 0.85rem;
    cursor: pointer;
    transition: all 0.2s ease;
    font-weight: 500;
}

.poi-btn:hover {
    background: rgba(88, 101, 242, 0.1);
    border-color: var(--accent);
}

.route-actions {
    display: flex;
    flex-direction: column;
    gap: 8px;
    margin-top: auto;
}

/* Map Container Styles */
.map-container {
    position: relative;
    background: #1a1a1a;
    display: flex;
    flex-direction: column;
}

.map-controls {
    position: absolute;
    top: 16px;
    left: 16px;
    z-index: 1000;
    display: flex;
    gap: 12px;
    pointer-events: auto;
}

.map-style-selector {
    display: flex;
    background: var(--card-bg);
    border-radius: 8px;
    padding: 4px;
    border: 1px solid rgba(255, 255, 255, 0.1);
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
    backdrop-filter: blur(8px);
}

.map-style {
    padding: 6px 12px;
    background: transparent;
    border: none;
    color: var(--text-secondary);
    border-radius: 6px;
    font-size: 0.85rem;
    cursor: pointer;
    transition: all 0.2s ease;
}

.map-style.active {
    background: var(--accent);
    color: white;
}

.map-layers {
    display: flex;
    gap: 8px;
}

.layer-toggle {
    padding: 6px 12px;
    background: var(--card-bg);
    border: 1px solid rgba(255, 255, 255, 0.1);
    border-radius: 8px;
    color: var(--text-secondary);
    font-size: 0.85rem;
    cursor: pointer;
    transition: all 0.2s ease;
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
    backdrop-filter: blur(8px);
}

.layer-toggle.active {
    background: var(--accent);
    color: white;
    border-color: var(--accent);
}

.map-display {
    flex: 1;
    position: relative;
    background: linear-gradient(135deg, #2d3748 0%, #1a202c 100%);
    min-height: 500px;
    height: 100%;
}

.map-placeholder {
    width: 100%;
    height: 100%;
    position: relative;
    display: flex;
    align-items: center;
    justify-content: center;
}

/* Leaflet Map Styles */
.leaflet-container {
    height: 100% !important;
    width: 100% !important;
    background: #1a1a1a;
    min-height: 500px;
}

.leaflet-control-container {
    font-family: inherit;
}

.leaflet-popup-content-wrapper {
    background: var(--card-bg);
    color: var(--text-primary);
    border-radius: 8px;
    border: 1px solid rgba(255, 255, 255, 0.1);
}

.leaflet-popup-tip {
    background: var(--card-bg);
    border: 1px solid rgba(255, 255, 255, 0.1);
}

.waypoint-marker {
    background: var(--accent);
    border: 3px solid white;
    border-radius: 50%;
    box-shadow: 0 2px 8px rgba(88, 101, 242, 0.4);
}

.poi-marker {
    background: rgba(255, 255, 255, 0.95);
    border: 2px solid var(--accent);
    border-radius: 50%;
    box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
}

.elevation-profile {
    background: var(--card-bg);
    border-top: 1px solid rgba(255, 255, 255, 0.1);
    padding: 16px 24px;
    min-height: 240px;
    position: relative;
}

.profile-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 12px;
}

.profile-header h4 {
    color: var(--text-primary);
    margin: 0;
    font-size: 1rem;
}

.profile-stats {
    display: flex;
    gap: 16px;
    font-size: 0.85rem;
    color: var(--text-secondary);
}

.profile-chart {
    margin-top: 16px;
    position: relative;
}

#elevationChart {
    width: 100% !important;
    height: 120px !important;
    cursor: crosshair;
}

.elevation-tooltip {
    position: absolute;
    background: var(--card-bg);
    border: 1px solid var(--accent);
    border-radius: 8px;
    padding: 12px;
    pointer-events: none;
    z-index: 1000;
    font-size: 0.85rem;
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
}

.elevation-tooltip div {
    margin-bottom: 4px;
    color: var(--text-secondary);
}

.elevation-tooltip div:last-child {
    margin-bottom: 0;
}

.elevation-tooltip span {
    color: var(--text-primary);
    font-weight: 600;
}

.elevation-legend {
    display: flex;
    gap: 16px;
    margin-top: 12px;
    justify-content: center;
    flex-wrap: wrap;
}

.legend-item {
    display: flex;
    align-items: center;
    gap: 6px;
    font-size: 0.8rem;
    color: var(--text-secondary);
}

.legend-color {
    width: 12px;
    height: 12px;
    border-radius: 2px;
}

@media (max-width: 1024px) {
    .route-planner {
        grid-template-columns: 1fr;
        height: auto;
        min-height: 500px;
    }
    
    .route-sidebar {
        max-height: 400px;
    }
    
    .map-container {
        height: 500px;
    }
}

/* Build Route Section */
.build-route-section h4 {
    color: var(--text-primary);
    margin: 0 0 8px 0;
    font-size: 1rem;
    font-weight: 600;
}

.instruction-text {
    color: var(--text-secondary);
    font-size: 0.85rem;
    margin: 0 0 12px 0;
}

.start-point-input {
    display: flex;
    flex-direction: column;
    gap: 8px;
}

.start-point-input input {
    padding: 10px 12px;
    background: rgba(255, 255, 255, 0.05);
    border: 1px solid rgba(255, 255, 255, 0.2);
    border-radius: 8px;
    color: var(--text-primary);
    font-size: 0.9rem;
}

/* Waypoint Controls */
.waypoint-controls {
    margin-top: 16px;
}

.btn-waypoint {
    width: 100%;
    padding: 12px 16px;
    background: rgba(255, 255, 255, 0.05);
    border: 1px solid rgba(255, 255, 255, 0.2);
    border-radius: 8px;
    color: var(--text-secondary);
    font-size: 0.9rem;
    font-weight: 500;
    cursor: pointer;
    transition: all 0.2s ease;
    display: flex;
    align-items: center;
    gap: 8px;
    justify-content: center;
}

.btn-waypoint:hover {
    background: rgba(255, 255, 255, 0.1);
    border-color: var(--accent);
    color: var(--text-primary);
}

.btn-waypoint.active {
    background: rgba(88, 101, 242, 0.1);
    border-color: var(--accent);
    color: var(--accent);
}

.btn-waypoint.active .waypoint-icon {
    animation: pulse 2s infinite;
}

.waypoint-help {
    margin-top: 8px;
    text-align: center;
}

.waypoint-help small {
    color: var(--text-secondary);
    font-size: 0.8rem;
}

@keyframes pulse {
    0%, 100% { transform: scale(1); }
    50% { transform: scale(1.1); }
}

/* Waypoint List */
.waypoint-list-section {
    margin-bottom: 24px;
}

.waypoint-list-section h4 {
    color: var(--text-primary);
    margin: 0 0 16px 0;
    font-size: 1rem;
    font-weight: 600;
}

.waypoint-list {
    display: flex;
    flex-direction: column;
    gap: 8px;
}

.waypoint-item {
    display: flex;
    align-items: center;
    gap: 12px;
    padding: 12px;
    background: rgba(255, 255, 255, 0.05);
    border: 1px solid rgba(255, 255, 255, 0.1);
    border-radius: 8px;
    cursor: grab;
    transition: all 0.2s ease;
}

.waypoint-item:hover {
    background: rgba(255, 255, 255, 0.08);
    border-color: rgba(255, 255, 255, 0.2);
}

.waypoint-item.dragging {
    opacity: 0.5;
    transform: rotate(2deg);
    cursor: grabbing;
}

.waypoint-drag-handle {
    color: var(--text-secondary);
    opacity: 0.5;
    transition: opacity 0.2s ease;
    cursor: grab;
}

.waypoint-item:hover .waypoint-drag-handle {
    opacity: 1;
}

.waypoint-marker-icon {
    width: 24px;
    height: 24px;
    background: #5865f2;
    color: white;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    font-weight: bold;
    font-size: 12px;
    flex-shrink: 0;
}

.waypoint-details {
    flex: 1;
    min-width: 0;
}

.waypoint-address {
    color: var(--text-primary);
    font-size: 0.9rem;
    font-weight: 500;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
}

.waypoint-coords {
    color: var(--text-secondary);
    font-size: 0.75rem;
    margin-top: 2px;
}

.waypoint-actions {
    display: flex;
    gap: 4px;
}

.waypoint-action-btn {
    width: 28px;
    height: 28px;
    border: none;
    border-radius: 6px;
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    transition: all 0.2s ease;
    opacity: 0.6;
}

.waypoint-action-btn:hover {
    opacity: 1;
}

.waypoint-action-btn.remove {
    background: rgba(239, 68, 68, 0.1);
    color: #ef4444;
}

.waypoint-action-btn.remove:hover {
    background: rgba(239, 68, 68, 0.2);
}

/* Routing Preferences */
.routing-preferences h4,
.map-display-prefs h4,
.route-stats-section h4,
.surface-type-section h4,
.my-routes-section h4 {
    color: var(--text-primary);
    margin: 0 0 16px 0;
    font-size: 1rem;
    font-weight: 600;
}

.ride-type-section,
.elevation-preference,
.surface-preference {
    margin-bottom: 16px;
}

.mode-toggle {
    margin-top: 16px;
}

/* Map Display Preferences */
.display-options {
    display: flex;
    flex-direction: column;
    gap: 12px;
}

/* Distance Display */
.distance-display {
    display: flex;
    align-items: baseline;
    gap: 8px;
    margin-bottom: 16px;
}

.distance-value {
    font-size: 2rem;
    font-weight: 700;
    color: var(--text-primary);
}

.distance-unit {
    font-size: 1rem;
    color: var(--text-secondary);
}

.distance-label {
    font-size: 0.9rem;
    color: var(--text-secondary);
}

/* Elevation Display */
.elevation-display {
    display: flex;
    flex-direction: column;
    gap: 8px;
}

.elevation-item {
    display: flex;
    justify-content: space-between;
    align-items: center;
}

.elevation-label {
    font-size: 0.85rem;
    color: var(--text-secondary);
}

.elevation-value {
    font-size: 0.9rem;
    font-weight: 600;
    color: var(--text-primary);
}

/* My Routes Section */
.route-list {
    margin-bottom: 12px;
}

.no-routes {
    color: var(--text-secondary);
    font-size: 0.85rem;
    font-style: italic;
    margin: 0;
}

.btn-small {
    padding: 6px 12px;
    font-size: 0.8rem;
}

/* Secondary Actions */
.secondary-actions {
    display: flex;
    gap: 8px;
    margin-top: 8px;
}

.secondary-actions button {
    flex: 1;
    padding: 8px 12px;
    font-size: 0.85rem;
}

@media (max-width: 768px) {
    .route-planner {
        grid-template-columns: 1fr;
    }
    
    .map-controls {
        flex-direction: column;
        gap: 8px;
    }
    
    .secondary-actions {
        flex-direction: column;
    }
}
</style>

<!-- Leaflet CSS and JS -->
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
<link rel="stylesheet" href="https://unpkg.com/leaflet-routing-machine@3.2.12/dist/leaflet-routing-machine.css" />
<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<script src="https://unpkg.com/leaflet-routing-machine@3.2.12/dist/leaflet-routing-machine.js"></script>
<script src="https://unpkg.com/leaflet.heat@0.2.0/dist/leaflet-heat.js"></script>
<!-- Chart.js for elevation profile -->
<script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>

<script>
// Route Planner State Management
class RoutePlanner {
    constructor() {
        this.map = null;
        this.routingControl = null;
        this.waypoints = [];
        this.pois = [];
        this.currentPOIMode = null;
        this.vehicleType = 'motorcycle'; // Default vehicle type
        this.currentRoute = null;
        this.elevationProfile = null;
        this.elevationChart = null;
        this.elevationData = [];
        this.preferences = {
            avoidHighways: false,
            avoidTolls: false,
            preferCurves: true,
            routeType: 'scenic',
            rideType: 'popular',
            elevationPref: 'any',
            surfacePref: 'any',
            manualMode: false
        };
        this.layers = {};
        this.overlays = {};
        this.distanceMarkers = [];
        this.surfaceOverlay = null;
        this.heatmapLayer = null;
        this.segmentsLayer = null;
        this.savedRoutes = [];
        this.waypointMode = false;
        this.elevationCache = new Map(); // Cache elevation data to reduce API calls
        this.updateWaypointListTimeout = null; // Debounce timer
        this.isUpdatingWaypointList = false; // Lock to prevent concurrent updates
    }

    async init() {
        console.log('RoutePlanner initialization starting...');
        this.initStarted = true;
        try {
            console.log('Step 1: Initializing map...');
            await this.initializeMap();
            console.log('‚úÖ Map initialized successfully');
            
            console.log('Step 2: Setting up event listeners...');
            this.setupEventListeners();
            console.log('‚úÖ Event listeners set up successfully');
            
            console.log('Step 2.5: Setting up map click events...');
            this.setupMapClickEvents();
            console.log('‚úÖ Map click events set up successfully');
            
            // Initialize bicycle mode indicators
            if (this.vehicleType === 'bicycle') {
                document.querySelectorAll('.bike-only').forEach(el => el.style.display = 'inline');
            }
            
            console.log('Step 3: Loading user location...');
            this.loadUserLocation();
            console.log('‚úÖ User location loading initiated');
            
            console.log('Step 4: Loading saved routes...');
            this.loadSavedRoutes();
            console.log('‚úÖ Saved routes loading initiated');
            
            this.initCompleted = true;
            console.log('üéâ RoutePlanner initialization complete!');
            
            // Make sure it's accessible globally
            window.routePlanner = this;
            console.log('‚úÖ RoutePlanner set as global variable');
            
        } catch (error) {
            console.error('‚ùå Error during RoutePlanner initialization:', error);
            console.error('Error stack:', error.stack);
            this.initError = error;
            throw error;
        }
    }

    async initializeMap() {
        console.log('Initializing map...');
        
        // Wait for DOM to be ready
        const mapContainer = document.getElementById('routeMap');
        if (!mapContainer) {
            console.error('Map container not found!');
            return;
        }
        
        console.log('Map container found:', mapContainer);
        
        try {
            // Initialize map with explicit height
            this.map = L.map('routeMap', {
                center: [39.8283, -98.5795],
                zoom: 5,
                zoomControl: true,
                scrollWheelZoom: true
            });
            
            console.log('Map initialized:', this.map);

            // Map tile layers
            this.layers.street = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                attribution: '¬© OpenStreetMap contributors',
                maxZoom: 19
            });

            this.layers.satellite = L.tileLayer('https://mt1.google.com/vt/lyrs=y&x={x}&y={y}&z={z}', {
                attribution: '¬© Google',
                maxZoom: 20
            });

            this.layers.terrain = L.tileLayer('https://{s}.tile.opentopomap.org/{z}/{x}/{y}.png', {
                attribution: '¬© OpenTopoMap contributors',
                maxZoom: 17
            });

            // Dark theme WITH labels and good contrast
            this.layers.dark = L.tileLayer('https://tiles.stadiamaps.com/tiles/alidade_smooth_dark/{z}/{x}/{y}{r}.png', {
                attribution: '¬© Stadia Maps ¬© OpenMapTiles ¬© OpenStreetMap contributors',
                maxZoom: 19
            });

            // Add default layer (dark theme)
            this.layers.dark.addTo(this.map);
            console.log('Street layer added');

            // Force map to resize after a short delay
            setTimeout(() => {
                this.map.invalidateSize();
                console.log('Map size invalidated');
            }, 100);

            // Initialize routing control
            this.initializeRouting();
            
        } catch (error) {
            console.error('Error initializing map:', error);
        }
    }

    initializeRouting() {
        console.log('Initializing routing with OSRM...');
        
        // Initialize routing control with router configuration
        this.routingControl = L.Routing.control({
            waypoints: [],
            router: this.createRouter(),
            createMarker: function() { return null; }, // Don't create default markers
            addWaypoints: false,
            routeWhileDragging: false,
            lineOptions: {
                styles: [{
                    color: '#5865f2',
                    weight: 6,
                    opacity: 0.9
                }]
            },
            show: false,
            fitSelectedRoutes: false
        });

        // Add event listeners with proper context binding
        this.routingControl.on('routesfound', (e) => {
            console.log('‚úÖ Route found successfully!');
            console.log('Route details:', e.routes[0]);
            if (e.routes && e.routes[0]) {
                this.handleRouteFound(e.routes[0]);
                this.currentRoute = e.routes[0];
            }
        });

        this.routingControl.on('routingerror', (e) => {
            console.error('‚ùå Routing error:', e);
            // Check if it's a context error and ignore it
            if (e.error && e.error.message && e.error.message.includes('updateElevationProfile')) {
                console.log('Ignoring context error, route calculation likely succeeded');
                return;
            }
            this.showNotification('Routing failed: ' + (e.error ? e.error.message : 'Unknown error'), 'error');
        });

        this.routingControl.on('routingstart', (e) => {
            console.log('üîÑ Starting route calculation...');
        });

        // Add to map
        this.routingControl.addTo(this.map);
        console.log('‚úÖ Routing control added to map');
        
        // Test routing is working
        console.log('Router object:', this.routingControl.getRouter());
    }

    createRouter() {
        // Use BRouter for bicycles, OSRM for motorcycles
        if (this.vehicleType === 'bicycle') {
            return this.createBRouterRouter();
        } else {
            return this.createOSRMRouter();
        }
    }
    
    createBRouterRouter() {
        // BRouter profiles based on surface preferences
        let profile = 'trekking'; // Default balanced profile
        
        // Map surface preferences to BRouter profiles
        switch (this.preferences.surfacePref) {
            case 'paved':
                profile = 'fastbike'; // Road cycling, prefers paved
                break;
            case 'gravel':
                profile = 'gravel'; // Gravel specific profile
                break;
            case 'trails':
                profile = 'mtb'; // Mountain bike profile, prefers trails
                break;
            case 'any':
            default:
                profile = 'trekking'; // All-around touring profile
                break;
        }
        
        console.log('üö¥ Creating BRouter with profile:', profile, 'surface pref:', this.preferences.surfacePref);
        
        // Create custom OSRM router that uses BRouter API
        // BRouter API is compatible with OSRM format
        const brouter = L.Routing.osrmv1({
            serviceUrl: `https://brouter.de/brouter/route/v1/${profile}`,
            profile: profile,
            timeout: 30 * 1000,
            // BRouter uses different parameter format
            routingOptions: function(waypoints) {
                // Convert waypoints to BRouter format
                const coords = waypoints.map(wp => `${wp.lng},${wp.lat}`).join('|');
                
                // Build custom parameters for BRouter
                const params = {
                    lonlats: coords,
                    profile: profile,
                    alternativeidx: 0,
                    format: 'geojson'
                };
                
                // Add elevation preferences
                if (this.preferences.elevationPref === 'flat') {
                    params.parameter = 'uphillcutoff=1.5|downhillcutoff=1.5';
                } else if (this.preferences.elevationPref === 'hilly') {
                    params.parameter = 'uphillcutoff=3.0|downhillcutoff=3.0';
                }
                
                return params;
            }.bind(this)
        });
        
        // Override the route method to handle BRouter's response format
        const originalRoute = brouter.route.bind(brouter);
        brouter.route = function(waypoints, callback, context, options) {
            // For BRouter, we need to make a custom request
            const coords = waypoints.map(wp => `${wp.latLng.lng},${wp.latLng.lat}`).join('|');
            const url = `https://brouter.de/brouter?lonlats=${coords}&profile=${profile}&alternativeidx=0&format=geojson`;
            
            fetch(url)
                .then(response => response.json())
                .then(data => {
                    if (data.features && data.features.length > 0) {
                        // Convert BRouter GeoJSON to OSRM-like format
                        const route = this._convertBRouterToOSRM(data.features[0]);
                        callback.call(context, null, [route]);
                    } else {
                        callback.call(context, { message: 'No route found' });
                    }
                })
                .catch(error => {
                    console.error('BRouter error:', error);
                    callback.call(context, error);
                });
        }.bind(this);
        
        // Add conversion method
        brouter._convertBRouterToOSRM = function(feature) {
            const coordinates = feature.geometry.coordinates.map(coord => L.latLng(coord[1], coord[0]));
            
            return {
                name: feature.properties.name || 'BRouter Route',
                coordinates: coordinates,
                summary: {
                    totalDistance: feature.properties['track-length'] || 0,
                    totalTime: feature.properties['total-time'] || 0
                },
                instructions: [], // BRouter doesn't provide turn-by-turn instructions
                waypoints: [],
                waypointIndices: [0, coordinates.length - 1]
            };
        };
        
        return brouter;
    }
    
    createOSRMRouter() {
        // Keep existing OSRM logic for motorcycles
        const profile = 'driving';
        
        // Build options based on preferences
        const options = {
            serviceUrl: 'https://router.project-osrm.org/route/v1',
            profile: profile,
            timeout: 30 * 1000
        };
        
        // OSRM public server limitation: Highway avoidance is not supported
        if (this.preferences.avoidHighways && this.vehicleType === 'motorcycle') {
            console.log('‚ö†Ô∏è Highway avoidance requested but not supported on public OSRM');
            
            this.showNotification(
                'Highway avoidance requires a custom routing server. ' +
                'The public OSRM server doesn\'t support this feature.',
                'info'
            );
        }
        
        console.log('üèçÔ∏è Creating OSRM router with profile:', profile);
        
        return L.Routing.osrmv1(options);
    }

    setupMapClickEvents() {
        this.map.on('click', (e) => {
            this.handleMapClick(e);
        });

        this.map.on('contextmenu', (e) => {
            this.handleRightClick(e);
        });
    }

    setupEventListeners() {
        // Route type switching
        document.querySelectorAll('.route-type').forEach(button => {
            button.addEventListener('click', (e) => {
                this.setVehicleType(e.target.dataset.type);
            });
        });

        // Map style switching
        document.querySelectorAll('.map-style').forEach(button => {
            button.addEventListener('click', (e) => {
                this.switchMapStyle(e.target.dataset.style);
            });
        });

        // Layer toggles
        document.querySelectorAll('.layer-toggle').forEach(button => {
            button.addEventListener('click', (e) => {
                this.toggleLayer(e.target.dataset.layer);
            });
        });

        // Route preferences - only for elements that actually exist

        // POI buttons
        document.querySelectorAll('.poi-btn').forEach(button => {
            button.addEventListener('click', (e) => {
                this.togglePOIMode(e.target.dataset.poi);
            });
        });


        // Route actions
        document.getElementById('clearRoute').addEventListener('click', () => this.clearRoute());
        document.getElementById('saveRoute').addEventListener('click', () => this.saveRoute());
        document.getElementById('shareRoute').addEventListener('click', () => this.shareRoute());
        document.getElementById('exportRoute').addEventListener('click', () => this.exportRoute());
        
        // Start from location button
        const useLocationBtn = document.getElementById('useMyLocation');
        console.log('Setting up event listener for useMyLocation button:', useLocationBtn);
        if (useLocationBtn) {
            useLocationBtn.addEventListener('click', () => {
                console.log('useMyLocation button clicked!');
                this.useMyLocationAsStart();
            });
            console.log('Event listener attached successfully');
        } else {
            console.error('useMyLocation button not found!');
        }
        
        // Waypoint mode button
        document.getElementById('addWaypointMode').addEventListener('click', () => {
            this.toggleWaypointMode();
        });
        
        // New routing preference listeners with safety checks
        const rideType = document.getElementById('rideType');
        if (rideType) {
            rideType.addEventListener('change', (e) => {
                this.preferences.rideType = e.target.value;
                this.recalculateRoute();
            });
        }
        
        const elevationPref = document.getElementById('elevationPref');
        if (elevationPref) {
            elevationPref.addEventListener('change', (e) => {
                this.preferences.elevationPref = e.target.value;
                this.recalculateRoute();
            });
        }
        
        const surfacePref = document.getElementById('surfacePref');
        if (surfacePref) {
            surfacePref.addEventListener('change', (e) => {
                this.preferences.surfacePref = e.target.value;
                this.recalculateRoute();
            });
        }
        
        const avoidHighways = document.getElementById('avoidHighways');
        if (avoidHighways) {
            avoidHighways.addEventListener('change', (e) => {
                this.preferences.avoidHighways = e.target.checked;
                this.recalculateRoute();
                this.showNotification(
                    e.target.checked ? 'Now avoiding highways' : 'Highways allowed', 
                    'info'
                );
            });
        }
        
        const manualMode = document.getElementById('manualMode');
        if (manualMode) {
            manualMode.addEventListener('change', (e) => {
                this.preferences.manualMode = e.target.checked;
                this.toggleManualMode(e.target.checked);
            });
        }
        
        // Map display preferences
        // Map display preferences with safety checks
        const showSurfaceType = document.getElementById('showSurfaceType');
        if (showSurfaceType) {
            showSurfaceType.addEventListener('change', (e) => {
                this.toggleSurfaceDisplay(e.target.checked);
            });
        }
        
        const showDistanceMarkers = document.getElementById('showDistanceMarkers');
        if (showDistanceMarkers) {
            showDistanceMarkers.addEventListener('change', (e) => {
                this.toggleDistanceMarkers(e.target.checked);
            });
        }
        
        const showHeatmaps = document.getElementById('showHeatmaps');
        if (showHeatmaps) {
            showHeatmaps.addEventListener('change', (e) => {
                this.toggleHeatmaps(e.target.checked);
            });
        }
        
        const showSegments = document.getElementById('showSegments');
        if (showSegments) {
            showSegments.addEventListener('change', (e) => {
                this.toggleSegments(e.target.checked);
            });
        }
        
        // Start point input
        const startInput = document.getElementById('startPointInput');
        if (startInput) {
            startInput.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    this.geocodeAndAddWaypoint(e.target.value);
                }
            });
        }
        
        // View all routes
        const viewAllRoutesBtn = document.getElementById('viewAllRoutes');
        if (viewAllRoutesBtn) {
            viewAllRoutesBtn.addEventListener('click', () => {
                this.showAllRoutes();
            });
        }
    }

    setVehicleType(type) {
        document.querySelectorAll('.route-type').forEach(b => b.classList.remove('active'));
        document.querySelector(`[data-type=\"${type}\"]`).classList.add('active');
        
        console.log('üö¥ Switching vehicle type to:', type);
        
        // Update the vehicle type instance variable
        this.vehicleType = type;
        
        // Update routing profile and recreate router for different vehicle types
        const profiles = {
            motorcycle: 'driving',
            bicycle: 'cycling'  // Uses bike paths, trails, and bike-friendly roads
        };
        
        const profile = profiles[type] || 'driving';
        console.log('üó∫Ô∏è Using routing profile:', profile);
        
        // Show/hide bicycle-specific feature indicators
        const bikeOnlyElements = document.querySelectorAll('.bike-only');
        if (type === 'bicycle') {
            bikeOnlyElements.forEach(el => el.style.display = 'inline');
            // Show info about BRouter features
            this.showNotification('üö¥ Bicycle mode: Surface and elevation preferences are now active!', 'success');
        } else {
            bikeOnlyElements.forEach(el => el.style.display = 'none');
        }
        
        if (this.routingControl) {
            // Update the router with new profile and current preferences
            this.routingControl.options.router = this.createRouter();
            
            // Recalculate existing route with new profile
            this.recalculateRoute();
            
            // Show notification about routing change
            const messages = {
                motorcycle: 'Routing optimized for motorcycles (roads only)',
                bicycle: 'Routing optimized for bicycles (includes bike paths and trails)'
            };
            this.showNotification(messages[type], 'info');
        }
    }

    switchMapStyle(style) {
        document.querySelectorAll('.map-style').forEach(b => b.classList.remove('active'));
        document.querySelector(`[data-style="${style}"]`).classList.add('active');
        
        // Remove current base layer and overlays
        Object.values(this.layers).forEach(layer => {
            if (this.map.hasLayer(layer)) {
                this.map.removeLayer(layer);
            }
        });
        
        // Add selected layer
        if (this.layers[style]) {
            this.layers[style].addTo(this.map);
        }
    }

    toggleLayer(layerName) {
        const button = document.querySelector(`[data-layer="${layerName}"]`);
        button.classList.toggle('active');
        
        if (layerName === 'traffic' && this.overlays.traffic) {
            if (this.map.hasLayer(this.overlays.traffic)) {
                this.map.removeLayer(this.overlays.traffic);
            } else {
                this.overlays.traffic.addTo(this.map);
            }
        }
        
        // Add other layer implementations here
        if (layerName === 'curves') {
            this.toggleCurvyRoadsOverlay(button.classList.contains('active'));
        }
    }

    toggleCurvyRoadsOverlay(show) {
        // Mock implementation - in real app, this would show roads with many curves
        if (show) {
            // Highlight curvy roads based on route preferences
            this.showNotification('Curvy roads highlighted', 'info');
        }
    }
    
    toggleWaypointMode() {
        this.waypointMode = !this.waypointMode;
        
        const button = document.getElementById('addWaypointMode');
        const instructionText = document.getElementById('instructionText');
        
        if (this.waypointMode) {
            button.classList.add('active');
            const waypointText = button.querySelector('.waypoint-text');
            if (waypointText) {
                waypointText.textContent = 'Click Map to Add Waypoints';
            }
            if (instructionText) {
                instructionText.textContent = 'Click the map to add waypoints';
            }
            this.map.getContainer().style.cursor = 'crosshair';
            this.showNotification('Waypoint mode enabled - click the map to add waypoints', 'info');
            
            // Ensure routing control doesn't interfere with waypoint clicks
            if (this.routingControl) {
                this.routingControl.options.addWaypoints = false;
            }
        } else {
            button.classList.remove('active');
            const waypointText = button.querySelector('.waypoint-text');
            if (waypointText) {
                waypointText.textContent = 'Click to Add Waypoints';
            }
            if (instructionText) {
                instructionText.textContent = 'Click the map or enter start point';
            }
            this.map.getContainer().style.cursor = '';
            this.showNotification('Waypoint mode disabled', 'info');
        }
    }

    togglePOIMode(poiType) {
        if (this.currentPOIMode === poiType) {
            this.currentPOIMode = null;
            this.map.getContainer().style.cursor = '';
            document.querySelectorAll('.poi-btn').forEach(b => b.classList.remove('active'));
        } else {
            this.currentPOIMode = poiType;
            this.map.getContainer().style.cursor = 'crosshair';
            document.querySelectorAll('.poi-btn').forEach(b => b.classList.remove('active'));
            document.querySelector(`[data-poi="${poiType}"]`).classList.add('active');
        }
    }

    handleMapClick(e) {
        console.log('üó∫Ô∏è Map clicked!', {
            latlng: e.latlng,
            poiMode: this.currentPOIMode,
            waypointMode: this.waypointMode,
            waypoints: this.waypoints.length
        });
        
        if (this.currentPOIMode) {
            console.log('Adding POI');
            this.addPOI(e.latlng, this.currentPOIMode);
            this.togglePOIMode(null);
        } else if (this.waypointMode) {
            console.log('‚úÖ Waypoint mode active, adding waypoint at:', e.latlng);
            
            if (this.insertAfterIndex !== undefined) {
                console.log('Inserting waypoint at index:', this.insertAfterIndex + 1);
                // Insert waypoint at specific position
                this.insertWaypointAt(e.latlng, this.insertAfterIndex + 1);
                this.insertAfterIndex = undefined;
                this.waypointMode = false;
                this.map.getContainer().style.cursor = '';
                document.getElementById('addWaypointMode').classList.remove('active');
                this.updateWaypointUI();
            } else {
                console.log('Adding waypoint at end');
                // Add waypoint at end
                this.addWaypoint(e.latlng);
                // After adding waypoint, turn off waypoint mode if we have enough waypoints
                if (this.waypoints.length >= 2) {
                    this.waypointMode = false;
                    this.map.getContainer().style.cursor = '';
                    document.getElementById('addWaypointMode').classList.remove('active');
                    this.updateWaypointUI();
                }
            }
        }
    }

    handleRightClick(e) {
        // Show context menu for advanced options
        this.showContextMenu(e.latlng, e.containerPoint);
    }

    showContextMenu(latlng, point) {
        // Create context menu
        const menu = document.createElement('div');
        menu.className = 'context-menu';
        menu.style.position = 'absolute';
        menu.style.left = point.x + 'px';
        menu.style.top = point.y + 'px';
        menu.style.background = 'var(--card-bg)';
        menu.style.border = '1px solid rgba(255,255,255,0.1)';
        menu.style.borderRadius = '8px';
        menu.style.padding = '8px';
        menu.style.zIndex = '1000';
        
        menu.innerHTML = `
            <div class="menu-item" onclick="routePlanner.addWaypoint(L.latLng(${latlng.lat}, ${latlng.lng}))">Add Waypoint</div>
            <div class="menu-item" onclick="routePlanner.addPOI(L.latLng(${latlng.lat}, ${latlng.lng}), 'gas')">Add Gas Station</div>
            <div class="menu-item" onclick="routePlanner.reverseGeocode(L.latLng(${latlng.lat}, ${latlng.lng}))">What's Here?</div>
        `;
        
        document.body.appendChild(menu);
        
        // Remove menu after 3 seconds or on next click
        setTimeout(() => {
            if (menu.parentNode) menu.parentNode.removeChild(menu);
        }, 3000);
    }

    async addWaypoint(latlng) {
        console.log('‚ûï Adding waypoint at:', latlng);
        console.log('Current waypoints before adding:', this.waypoints.length, this.waypoints);
        console.trace('addWaypoint called from:');
        
        const letter = String.fromCharCode(65 + this.waypoints.length);
        
        const marker = L.marker(latlng, {
            draggable: true,
            icon: L.divIcon({
                className: 'waypoint-marker',
                html: `<div style="background: #5865f2; color: white; width: 32px; height: 32px; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-weight: bold; border: 3px solid white; box-shadow: 0 2px 8px rgba(88, 101, 242, 0.4); cursor: grab;">${letter}</div>`,
                iconSize: [32, 32],
                iconAnchor: [16, 16]
            })
        }).addTo(this.map);

        // Enhanced drag handling using shared method
        this.setupWaypointDragEvents(marker);

        // Add popup with waypoint info
        await this.updateWaypointPopup(marker, letter, this.waypoints.length);

        // Check for duplicate waypoints at the same location
        const isDuplicate = this.waypoints.some(existingMarker => {
            const existingLatLng = existingMarker.getLatLng();
            return existingLatLng.lat === latlng.lat && existingLatLng.lng === latlng.lng;
        });
        
        if (isDuplicate) {
            console.warn('‚ö†Ô∏è Duplicate waypoint detected at same location, skipping');
            this.map.removeLayer(marker);
            return;
        }
        
        this.waypoints.push(marker);
        console.log('üìç Total waypoints:', this.waypoints.length);
        console.log('Waypoints after adding:', this.waypoints.map((m, i) => {
            const pos = m.getLatLng();
            return `${String.fromCharCode(65 + i)}(${pos.lat.toFixed(4)},${pos.lng.toFixed(4)})`;
        }).join(', '));
        
        // Update waypoint counter in UI
        this.updateWaypointUI();
        
        // Always update route when we have 2 or more waypoints
        if (this.waypoints.length >= 2) {
            console.log('üó∫Ô∏è Triggering route calculation...');
            this.updateRoute();
        } else {
            // Show instruction for next waypoint
            this.showNotification('Add another waypoint to create a route', 'info');
        }
    }
    
    async updateWaypointPopup(marker, letter, index) {
        try {
            const latlng = marker.getLatLng();
            const address = await this.reverseGeocode(latlng);
            marker.bindPopup(`
                <div style="text-align: center; min-width: 150px;">
                    <strong>Waypoint ${letter}</strong><br>
                    <small style="color: #666; font-size: 11px;">${address}</small><br>
                    <div style="margin-top: 8px; display: flex; gap: 4px;">
                        <button onclick="routePlanner.removeWaypoint(${index})" style="padding: 4px 8px; background: #ef4444; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 11px;">Remove</button>
                        <button onclick="routePlanner.insertWaypointAfter(${index})" style="padding: 4px 8px; background: #10b981; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 11px;">Insert After</button>
                    </div>
                </div>
            `);
        } catch (error) {
            console.warn('Could not get address for waypoint:', error);
            marker.bindPopup(`
                <div style="text-align: center;">
                    <strong>Waypoint ${letter}</strong><br>
                    <div style="margin-top: 8px; display: flex; gap: 4px;">
                        <button onclick="routePlanner.removeWaypoint(${index})" style="padding: 4px 8px; background: #ef4444; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 11px;">Remove</button>
                        <button onclick="routePlanner.insertWaypointAfter(${index})" style="padding: 4px 8px; background: #10b981; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 11px;">Insert After</button>
                    </div>
                </div>
            `);
        }
    }
    
    updateWaypointUI() {
        const count = this.waypoints.length;
        const instructionText = document.getElementById('instructionText');
        
        if (count === 0) {
            instructionText.textContent = 'Click the map or enter start point';
        } else if (count === 1) {
            instructionText.textContent = 'Add destination waypoint';
        } else {
            instructionText.textContent = `Route with ${count} waypoints`;
        }
        
        // Update waypoint list with debounce to prevent multiple rapid calls
        if (this.updateWaypointListTimeout) {
            clearTimeout(this.updateWaypointListTimeout);
        }
        
        this.updateWaypointListTimeout = setTimeout(() => {
            this.updateWaypointList();
        }, 100);
    }
    
    async updateWaypointList() {
        // Prevent concurrent updates
        if (this.isUpdatingWaypointList) {
            console.log('‚è≥ Update already in progress, skipping...');
            return;
        }
        
        this.isUpdatingWaypointList = true;
        
        try {
            const waypointListSection = document.getElementById('waypointListSection');
            const waypointList = document.getElementById('waypointList');
            
            console.log('üîÑ Updating waypoint list, waypoints array:', this.waypoints.length, this.waypoints);
            console.trace('updateWaypointList called from:');
            
            // Check if there are multiple waypoint list elements
            const allWaypointLists = document.querySelectorAll('#waypointList');
            console.log('üîç Number of waypoint list elements found:', allWaypointLists.length);
            
            if (allWaypointLists.length > 1) {
                console.error('‚ùå Multiple waypoint list elements found! This is the problem.');
            }
            
            // Add a unique ID to track this update
            const updateId = Date.now();
            console.log('üìã Update ID:', updateId);
        
        // Clean up any duplicate waypoint markers
        const uniqueWaypoints = [];
        const seenLocations = new Set();
        
        for (const marker of this.waypoints) {
            const latlng = marker.getLatLng();
            const locationKey = `${latlng.lat.toFixed(6)},${latlng.lng.toFixed(6)}`;
            
            if (!seenLocations.has(locationKey)) {
                seenLocations.add(locationKey);
                uniqueWaypoints.push(marker);
            } else {
                console.warn('üßπ Removing duplicate waypoint at:', locationKey);
                this.map.removeLayer(marker);
            }
        }
        
        if (uniqueWaypoints.length !== this.waypoints.length) {
            console.log('üîß Cleaned up waypoints:', this.waypoints.length, '->', uniqueWaypoints.length);
            this.waypoints = uniqueWaypoints;
            // Refresh markers to ensure they're labeled correctly
            this.refreshWaypointMarkers();
        }
        
        if (this.waypoints.length === 0) {
            waypointListSection.style.display = 'none';
            return;
        }
        
        waypointListSection.style.display = 'block';
        
        // Make absolutely sure we're clearing the list
        while (waypointList.firstChild) {
            waypointList.removeChild(waypointList.firstChild);
        }
        
        console.log('üìù Creating waypoint list items for', this.waypoints.length, 'waypoints');
        
        for (let i = 0; i < this.waypoints.length; i++) {
            const marker = this.waypoints[i];
            const latlng = marker.getLatLng();
            const letter = String.fromCharCode(65 + i);
            
            let address = 'Loading address...';
            try {
                address = await this.reverseGeocode(latlng);
            } catch (error) {
                address = `${latlng.lat.toFixed(4)}, ${latlng.lng.toFixed(4)}`;
            }
            
            const waypointItem = document.createElement('div');
            waypointItem.className = 'waypoint-item';
            waypointItem.draggable = true;
            waypointItem.dataset.index = i;
            
            waypointItem.innerHTML = `
                <div class="waypoint-drag-handle">
                    <svg width="12" height="12" viewBox="0 0 12 12" fill="currentColor">
                        <circle cx="2" cy="3" r="1"/>
                        <circle cx="6" cy="3" r="1"/>
                        <circle cx="10" cy="3" r="1"/>
                        <circle cx="2" cy="6" r="1"/>
                        <circle cx="6" cy="6" r="1"/>
                        <circle cx="10" cy="6" r="1"/>
                        <circle cx="2" cy="9" r="1"/>
                        <circle cx="6" cy="9" r="1"/>
                        <circle cx="10" cy="9" r="1"/>
                    </svg>
                </div>
                <div class="waypoint-marker-icon">${letter}</div>
                <div class="waypoint-details">
                    <div class="waypoint-address">${address}</div>
                    <div class="waypoint-coords">${latlng.lat.toFixed(4)}, ${latlng.lng.toFixed(4)}</div>
                </div>
                <div class="waypoint-actions">
                    <button class="waypoint-action-btn remove" onclick="routePlanner.removeWaypoint(${i})" title="Remove waypoint">
                        <svg width="14" height="14" viewBox="0 0 24 24" fill="currentColor">
                            <path d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41z"/>
                        </svg>
                    </button>
                </div>
            `;
            
            // Add drag and drop event listeners
            waypointItem.addEventListener('dragstart', (e) => {
                e.dataTransfer.setData('text/plain', i.toString());
                waypointItem.classList.add('dragging');
            });
            
            waypointItem.addEventListener('dragend', () => {
                waypointItem.classList.remove('dragging');
            });
            
            waypointItem.addEventListener('dragover', (e) => {
                e.preventDefault();
            });
            
            waypointItem.addEventListener('drop', (e) => {
                e.preventDefault();
                const draggedIndex = parseInt(e.dataTransfer.getData('text/plain'));
                const targetIndex = parseInt(waypointItem.dataset.index);
                
                if (draggedIndex !== targetIndex) {
                    this.reorderWaypoints(draggedIndex, targetIndex);
                }
            });
            
            waypointList.appendChild(waypointItem);
            console.log(`‚úÖ Added waypoint ${letter} to list at index ${i}`);
        }
        
        console.log('üìä Final waypoint list children:', waypointList.children.length);
        } finally {
            this.isUpdatingWaypointList = false;
        }
    }
    
    reorderWaypoints(fromIndex, toIndex) {
        if (fromIndex === toIndex) return;
        
        // Remove the waypoint from its current position
        const [movedWaypoint] = this.waypoints.splice(fromIndex, 1);
        
        // Insert it at the new position
        this.waypoints.splice(toIndex, 0, movedWaypoint);
        
        // Update all waypoint markers and icons
        this.refreshWaypointMarkers();
        
        // Update the waypoint list
        this.updateWaypointList();
        
        // Update the route
        if (this.waypoints.length >= 2) {
            this.updateRoute();
        }
    }
    
    refreshWaypointMarkers() {
        console.log('üîÑ Refreshing waypoint markers, total waypoints:', this.waypoints.length);
        
        // Simply update the icon for each waypoint marker
        this.waypoints.forEach((marker, index) => {
            const letter = String.fromCharCode(65 + index);
            console.log(`üìç Updating marker ${index} to letter ${letter}`, marker);
            
            try {
                // Check if marker is still on the map
                if (!this.map.hasLayer(marker)) {
                    console.error(`‚ùå Marker ${index} (${letter}) is not on the map! Re-adding it.`);
                    marker.addTo(this.map);
                }
                
                marker.setIcon(L.divIcon({
                    className: 'waypoint-marker',
                    html: `<div style="background: #5865f2; color: white; width: 32px; height: 32px; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-weight: bold; border: 3px solid white; box-shadow: 0 2px 8px rgba(88, 101, 242, 0.4); cursor: grab;">${letter}</div>`,
                    iconSize: [32, 32],
                    iconAnchor: [16, 16]
                }));
                
                console.log(`‚úÖ Successfully updated marker ${index} to letter ${letter}`);
            } catch (error) {
                console.error(`‚ùå Error updating marker ${index}:`, error);
            }
            
            // Update popup with correct index
            this.updateWaypointPopup(marker, letter, index);
        });
        
        console.log('‚úÖ All waypoint markers refreshed');
    }
    
    insertWaypointAfter(index) {
        // Temporarily enable waypoint mode for next click
        this.waypointMode = true;
        this.insertAfterIndex = index;
        this.showNotification('Click the map to insert a new waypoint', 'info');
        this.map.getContainer().style.cursor = 'crosshair';
    }
    
    async insertWaypointAt(latlng, insertIndex) {
        console.log('‚ûï Inserting waypoint at index:', insertIndex);
        
        // Create the new marker
        const marker = L.marker(latlng, {
            draggable: true,
            icon: L.divIcon({
                className: 'waypoint-marker',
                html: `<div style="background: #5865f2; color: white; width: 32px; height: 32px; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-weight: bold; border: 3px solid white; box-shadow: 0 2px 8px rgba(88, 101, 242, 0.4); cursor: grab;">?</div>`,
                iconSize: [32, 32],
                iconAnchor: [16, 16]
            })
        }).addTo(this.map);

        // Add the same drag events as regular waypoints
        this.setupWaypointDragEvents(marker);
        
        // Insert at the specified position
        this.waypoints.splice(insertIndex, 0, marker);
        
        // Re-label all waypoints
        this.relabelAllWaypoints();
        
        // Update UI and route
        this.updateWaypointUI();
        if (this.waypoints.length >= 2) {
            this.updateRoute();
        }
        
        this.showNotification('Waypoint inserted successfully', 'success');
    }
    
    setupWaypointDragEvents(marker) {
        let isDragging = false;
        
        marker.on('dragstart', () => {
            isDragging = true;
            marker.getElement().style.cursor = 'grabbing';
        });


        marker.on('dragend', () => {
            isDragging = false;
            marker.getElement().style.cursor = 'grab';
            
            if (this.waypoints.length >= 2) {
                this.updateRoute();
            }
            
            // Update popup with new location
            const index = this.waypoints.indexOf(marker);
            const letter = String.fromCharCode(65 + index);
            this.updateWaypointPopup(marker, letter, index);
        });
    }
    
    relabelAllWaypoints() {
        this.waypoints.forEach((marker, index) => {
            const letter = String.fromCharCode(65 + index);
            marker.setIcon(L.divIcon({
                className: 'waypoint-marker',
                html: `<div style="background: #5865f2; color: white; width: 32px; height: 32px; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-weight: bold; border: 3px solid white; box-shadow: 0 2px 8px rgba(88, 101, 242, 0.4); cursor: grab;">${letter}</div>`,
                iconSize: [32, 32],
                iconAnchor: [16, 16]
            }));
            
            // Update popup
            this.updateWaypointPopup(marker, letter, index);
        });
    }

    addPOI(latlng, type) {
        const icons = {
            gas: '‚õΩ',
            food: 'üçî',
            scenic: 'üì∏',
            mechanic: 'üîß'
        };

        const marker = L.marker(latlng, {
            icon: L.divIcon({
                className: 'poi-marker',
                html: `<div style="background: rgba(255, 255, 255, 0.95); border: 2px solid var(--accent); border-radius: 50%; width: 24px; height: 24px; display: flex; align-items: center; justify-content: center; box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);">${icons[type]}</div>`,
                iconSize: [24, 24],
                iconAnchor: [12, 12]
            })
        }).addTo(this.map);

        marker.bindPopup(`
            <div>
                <strong>${type.charAt(0).toUpperCase() + type.slice(1)} Stop</strong><br>
                <button onclick="routePlanner.removePOI(${this.pois.length})" style="margin-top: 8px; padding: 4px 8px; background: #dc3545; color: white; border: none; border-radius: 4px; cursor: pointer;">Remove</button>
            </div>
        `);

        this.pois.push({ marker, type, latlng });
    }

    removeWaypoint(index) {
        console.log(`üóëÔ∏è Removing waypoint at index ${index}`);
        console.trace('removeWaypoint called from:');
        
        if (index >= 0 && index < this.waypoints.length) {
            const marker = this.waypoints[index];
            console.log('Waypoints before removal:', this.waypoints.map((m, i) => {
                const pos = m.getLatLng();
                return `${String.fromCharCode(65 + i)}(${pos.lat.toFixed(4)},${pos.lng.toFixed(4)})`;
            }).join(', '));
            
            // Remove from map
            this.map.removeLayer(marker);
            
            // Remove from array
            this.waypoints.splice(index, 1);
            
            console.log('Waypoints after removal:', this.waypoints.map((m, i) => {
                const pos = m.getLatLng();
                return `${String.fromCharCode(65 + i)}(${pos.lat.toFixed(4)},${pos.lng.toFixed(4)})`;
            }).join(', '));
            
            // Refresh all waypoint markers to update letters and popups
            this.refreshWaypointMarkers();
            
            // Update UI
            this.updateWaypointUI();
            
            // Update route if we still have enough waypoints
            if (this.waypoints.length >= 2) {
                this.updateRoute();
            } else {
                // Clear the route if we have less than 2 waypoints
                this.clearRouteDisplay();
            }
        } else {
            console.error(`‚ùå Invalid waypoint index: ${index}`);
        }
    }

    removePOI(index) {
        if (this.pois[index]) {
            this.map.removeLayer(this.pois[index].marker);
            this.pois.splice(index, 1);
        }
    }

    async updateRoute() {
        if (this.waypoints.length < 2) {
            console.log('‚ùå Not enough waypoints for routing:', this.waypoints.length);
            this.clearRouteDisplay();
            this.routingControl.setWaypoints([]);
            return;
        }

        console.log('üó∫Ô∏è Updating route with', this.waypoints.length, 'waypoints');
        console.log('Current waypoints array:', this.waypoints);
        
        // Make sure we're not duplicating waypoints
        const uniqueWaypoints = this.waypoints.filter((marker, index, self) => 
            self.indexOf(marker) === index
        );
        
        if (uniqueWaypoints.length !== this.waypoints.length) {
            console.warn('‚ö†Ô∏è Duplicate waypoints detected! Cleaning up...');
            this.waypoints = uniqueWaypoints;
        }
        
        const waypoints = this.waypoints.map(marker => marker.getLatLng());
        console.log('üìç Waypoint coordinates:', waypoints);
        
        try {
            // Set waypoints directly - Leaflet Routing Machine will handle the conversion
            console.log('üìç Setting waypoints on routing control...');
            this.routingControl.setWaypoints(waypoints);
            console.log('‚úÖ Waypoints set successfully, waiting for route calculation...');
        } catch (error) {
            console.error('‚ùå Error setting waypoints:', error);
            this.showNotification('Error calculating route: ' + error.message, 'error');
        }
    }

    handleRouteFound(route) {
        console.log('üéØ Route found and handling:', route);
        this.currentRoute = route;
        
        // Clear any existing route line
        if (this.routeLine) {
            this.map.removeLayer(this.routeLine);
        }
        
        // Draw the route line manually to ensure it shows
        if (route && route.coordinates && route.coordinates.length > 0) {
            console.log('‚úÖ Drawing route line with', route.coordinates.length, 'coordinates');
            
            // Convert coordinates to LatLng array
            const latlngs = route.coordinates.map(coord => [coord.lat, coord.lng]);
            
            // Create and add the route polyline
            this.routeLine = L.polyline(latlngs, {
                color: '#5865f2',
                weight: 6,
                opacity: 0.8,
                smoothFactor: 1,
                lineCap: 'round',
                lineJoin: 'round'
            }).addTo(this.map);
            
            console.log('‚úÖ Route line added to map');
            
            // Fit map to show the route
            this.map.fitBounds(this.routeLine.getBounds().pad(0.1));
            
        } else {
            console.warn('‚ùå Route has no coordinates');
        }
        
        // Update stats
        this.updateRouteStats(route);
        this.updateElevationProfile(route);
        this.analyzeCurves(route);
        this.estimateSurfaceTypes(route);
    }

    updateRouteStats(route) {
        const distance = (route.summary.totalDistance / 1609.34).toFixed(1);
        const timeInMinutes = Math.round(route.summary.totalTime / 60);
        const hours = Math.floor(timeInMinutes / 60);
        const minutes = timeInMinutes % 60;
        
        document.getElementById('routeDistance').textContent = distance;
        document.getElementById('routeTime').textContent = `${hours}h ${minutes}m`;
        
        // Calculate elevation gain from route coordinates
        this.calculateElevation(route.coordinates);
    }

    async calculateElevation(coordinates) {
        if (!coordinates || coordinates.length < 2) {
            this.showNoRouteMessage();
            return;
        }

        console.log('üèîÔ∏è Calculating real elevation profile for', coordinates.length, 'points');
        
        // Show loading state
        const elevationMax = document.getElementById('elevationMax');
        const elevationMin = document.getElementById('elevationMin');
        const avgGrade = document.getElementById('avgGrade');
        
        if (elevationMax) elevationMax.textContent = 'Loading...';
        if (elevationMin) elevationMin.textContent = 'Loading...';
        if (avgGrade) avgGrade.textContent = 'Loading...';

        try {
            // Hide no route message and show chart elements
            document.getElementById('noRouteMessage').style.display = 'none';
            document.getElementById('elevationChart').style.display = 'block';
            document.getElementById('elevationStats').style.display = 'flex';
            document.getElementById('elevationLegend').style.display = 'flex';
            
            // Calculate distances and get elevation data (this will now use real API)
            const routeData = await this.processRouteForElevation(coordinates);
            this.elevationData = routeData;
            
            // Calculate statistics
            const stats = this.calculateElevationStats(routeData);
            
            // Update UI
            document.getElementById('routeElevation').textContent = `${Math.round(stats.totalGain)} ft`;
            document.getElementById('elevationLost').textContent = `${Math.round(stats.totalLoss)} ft`;
            document.getElementById('elevationMax').textContent = `${Math.round(stats.maxElevation)} ft`;
            document.getElementById('elevationMin').textContent = `${Math.round(stats.minElevation)} ft`;
            document.getElementById('avgGrade').textContent = `${stats.avgGrade.toFixed(1)}%`;
            
            // Create or update elevation chart
            this.createElevationChart(routeData);
            
            // Show climb categorizations
            this.displayClimbs(stats.climbs, routeData);
            
            // Add data source indicator
            this.showElevationDataSource(true);
            
            console.log('‚úÖ Real elevation profile complete');
            this.showNotification('Real elevation data loaded!', 'success');
            
        } catch (error) {
            console.error('Elevation calculation error:', error);
            this.showNotification('Error loading elevation data, using fallback', 'warning');
            
            // Reset loading indicators on error
            if (elevationMax) elevationMax.textContent = '-- ft';
            if (elevationMin) elevationMin.textContent = '-- ft';
            if (avgGrade) avgGrade.textContent = '--%';
            
            this.hideElevationProfile();
        }
    }

    async processRouteForElevation(coordinates) {
        if (!coordinates || coordinates.length < 2) return [];
        
        console.log(`üó∫Ô∏è Processing ${coordinates.length} route coordinates from OSRM`);
        
        // Use actual route coordinates for elevation sampling (follows real road geometry)
        const elevationPoints = this.prepareElevationPoints(coordinates);
        console.log(`üìç Using ${elevationPoints.length} points for elevation sampling`);
        
        const routeData = [];
        let cumulativeDistance = 0;
        
        // Get elevations for all points in batch (much faster!)
        console.log('üöÄ Fetching elevations in batch...');
        const elevations = await this.getBatchElevations(elevationPoints);
        
        // Process elevation points with batch elevation data
        for (let i = 0; i < elevationPoints.length; i++) {
            const point = elevationPoints[i];
            
            // Calculate distance from previous point
            if (i > 0) {
                const prevPoint = elevationPoints[i - 1];
                const segmentDistance = this.calculateDistance(
                    [prevPoint.lat, prevPoint.lng],
                    [point.lat, point.lng]
                ) / 1609.34; // Convert to miles
                cumulativeDistance += segmentDistance;
            }
            
            // Get elevation from batch results
            const elevation = elevations[i] || 0;
            
            // Calculate grade if not first point
            let grade = 0;
            if (i > 0 && routeData.length > 0) {
                const prevRoutePoint = routeData[routeData.length - 1];
                const elevationChange = elevation - prevRoutePoint.elevation; // feet
                const distanceChange = (cumulativeDistance - prevRoutePoint.distance) * 5280; // miles to feet
                if (distanceChange > 10) { // Minimum distance to avoid noise
                    grade = (elevationChange / distanceChange) * 100;
                    // Allow realistic variation - some sections can be steep
                    grade = Math.max(-18, Math.min(18, grade));
                }
            }
            
            routeData.push({
                distance: cumulativeDistance,
                elevation: elevation,
                grade: grade,
                lat: point.lat,
                lng: point.lng
            });
        }
        
        console.log(`‚úÖ Processed ${routeData.length} elevation points`);
        
        // Apply smoothing to reduce noise and unrealistic grade spikes
        return this.smoothElevationData(routeData);
    }
    
    prepareElevationPoints(coordinates) {
        // Interpolate additional points for better elevation resolution
        const TARGET_SPACING = 100; // meters - balance between detail and noise
        const interpolatedPoints = [];
        
        console.log(`üìç Starting with ${coordinates.length} OSRM route coordinates`);
        
        for (let i = 0; i < coordinates.length - 1; i++) {
            const start = coordinates[i];
            const end = coordinates[i + 1];
            
            // Always include the start point
            interpolatedPoints.push(start);
            
            // Calculate distance between consecutive points
            const distance = this.calculateDistance(
                [start.lat, start.lng],
                [end.lat, end.lng]
            );
            
            // If distance is greater than target spacing, interpolate points
            if (distance > TARGET_SPACING) {
                const numInterpolated = Math.floor(distance / TARGET_SPACING);
                
                for (let j = 1; j <= numInterpolated; j++) {
                    const ratio = j / (numInterpolated + 1);
                    interpolatedPoints.push({
                        lat: start.lat + (end.lat - start.lat) * ratio,
                        lng: start.lng + (end.lng - start.lng) * ratio
                    });
                }
            }
        }
        
        // Add the last point
        if (coordinates.length > 0) {
            interpolatedPoints.push(coordinates[coordinates.length - 1]);
        }
        
        console.log(`üìà Interpolated to ${interpolatedPoints.length} points for detailed elevation (${TARGET_SPACING}m spacing)`);
        
        return interpolatedPoints;
    }
    
    smoothElevationData(routeData) {
        if (routeData.length < 5) return routeData;
        
        console.log('üèîÔ∏è Applying advanced elevation smoothing');
        
        // First pass: Remove obvious spikes/outliers
        const cleaned = this.removeElevationOutliers(routeData);
        
        // Second pass: Apply adaptive smoothing based on gradient changes
        const smoothedData = [...cleaned];
        
        // Use Gaussian-like kernel for smoother results
        const kernel = [0.06, 0.24, 0.4, 0.24, 0.06]; // Gaussian approximation
        
        for (let i = 2; i < smoothedData.length - 2; i++) {
            // Simple 3-point average - preserve more terrain detail
            smoothedData[i].elevation = (
                cleaned[i - 1].elevation * 0.25 +
                cleaned[i].elevation * 0.5 +
                cleaned[i + 1].elevation * 0.25
            );
        }
        
        // Recalculate grades with smoothed elevations
        for (let i = 1; i < smoothedData.length; i++) {
            // Use a smaller window - just 1-2 points ahead/behind
            // This gives ~100-200ft of distance which is similar to bike computers
            let startIdx = Math.max(0, i - 1);
            let endIdx = Math.min(smoothedData.length - 1, i + 1);
            
            const elevationChange = smoothedData[endIdx].elevation - smoothedData[startIdx].elevation;
            const distanceChange = (smoothedData[endIdx].distance - smoothedData[startIdx].distance) * 5280;
            
            if (distanceChange > 20) { // Minimum ~20 feet
                let grade = (elevationChange / distanceChange) * 100;
                
                // Don't over-constrain - real roads can have short steep sections
                // But anything over 20% sustained is likely an error
                grade = Math.max(-20, Math.min(20, grade));
                
                smoothedData[i].grade = grade;
            } else {
                // Too short a distance, use previous grade
                smoothedData[i].grade = smoothedData[i - 1]?.grade || 0;
            }
        }
        
        console.log('‚úÖ Advanced elevation smoothing complete');
        return smoothedData;
    }
    
    removeElevationOutliers(routeData) {
        // Remove GPS/API errors that create impossible elevation spikes
        const cleaned = [...routeData];
        
        // First pass: Remove obvious spikes
        for (let i = 1; i < cleaned.length - 1; i++) {
            const prev = cleaned[i - 1].elevation;
            const current = cleaned[i].elevation;
            const next = cleaned[i + 1].elevation;
            
            // Calculate implied grade from point to point
            const distance = (cleaned[i].distance - cleaned[i - 1].distance) * 5280; // to feet
            if (distance > 0) {
                const impliedGrade = Math.abs((current - prev) / distance) * 100;
                
                // Only remove truly impossible grades (>25%)
                if (impliedGrade > 25) {
                    // Use linear interpolation
                    cleaned[i].elevation = prev + (next - prev) * 0.5;
                    continue;
                }
            }
            
            // Check if current point is a spike
            const prevDiff = Math.abs(current - prev);
            const nextDiff = Math.abs(current - next);
            const throughDiff = Math.abs(next - prev);
            
            // More aggressive spike detection
            if (prevDiff + nextDiff > throughDiff * 2 && prevDiff > 30 && nextDiff > 30) {
                // Replace spike with interpolated value
                cleaned[i].elevation = (prev + next) / 2;
            }
        }
        
        // Second pass: Ensure no impossible grade changes remain
        for (let i = 1; i < cleaned.length; i++) {
            const elevChange = Math.abs(cleaned[i].elevation - cleaned[i - 1].elevation);
            const distance = (cleaned[i].distance - cleaned[i - 1].distance) * 5280;
            
            if (distance > 0 && elevChange / distance > 0.20) { // >20% grade
                // Limit the elevation change to max 18% grade
                const maxChange = distance * 0.18;
                const direction = cleaned[i].elevation > cleaned[i - 1].elevation ? 1 : -1;
                cleaned[i].elevation = cleaned[i - 1].elevation + (maxChange * direction);
            }
        }
        
        return cleaned;
    }
    
    categorizeClimb(climb) {
        // Categorize climbs based on difficulty (similar to cycling race categories)
        // Using a simplified version of the fiets index: difficulty = (elevation_gain^2 / distance) + avgGrade
        
        const gainMeters = climb.totalGain * 0.3048; // Convert feet to meters
        const distanceKm = climb.distance * 0.0003048; // Convert feet to km
        const difficulty = (gainMeters * gainMeters / (distanceKm * 10)) + climb.avgGrade;
        
        let category;
        let color;
        
        if (difficulty > 150) {
            category = 'HC'; // Hors Cat√©gorie (beyond categorization)
            color = '#dc2626'; // red-600
        } else if (difficulty > 80) {
            category = '1';
            color = '#ea580c'; // orange-600
        } else if (difficulty > 50) {
            category = '2';
            color = '#f59e0b'; // amber-500
        } else if (difficulty > 30) {
            category = '3';
            color = '#84cc16'; // lime-500
        } else if (difficulty > 15) {
            category = '4';
            color = '#10b981'; // emerald-500
        } else {
            category = '5';
            color = '#06b6d4'; // cyan-500
        }
        
        return {
            ...climb,
            category,
            color,
            difficulty: Math.round(difficulty),
            distanceMi: (climb.distance / 5280).toFixed(1),
            gainFt: Math.round(climb.totalGain)
        };
    }
    
    async getBatchElevations(points) {
        if (!points || points.length === 0) return [];
        
        console.log(`üöÄ Batch elevation request for ${points.length} points`);
        
        // Check cache first for all points
        const cachedResults = [];
        const uncachedPoints = [];
        const uncachedIndices = [];
        
        for (let i = 0; i < points.length; i++) {
            const point = points[i];
            const cacheKey = `${point.lat.toFixed(5)},${point.lng.toFixed(5)}`;
            
            if (this.elevationCache.has(cacheKey)) {
                cachedResults[i] = this.elevationCache.get(cacheKey);
            } else {
                uncachedPoints.push(point);
                uncachedIndices.push(i);
            }
        }
        
        console.log(`üìã Found ${points.length - uncachedPoints.length} cached, fetching ${uncachedPoints.length} new`);
        
        // If all points are cached, return immediately
        if (uncachedPoints.length === 0) {
            return cachedResults;
        }
        
        try {
            // Process points in chunks to avoid URL length limits and API timeouts
            // URL limit calculation: ~25 chars per coordinate, max ~5000 chars safe = 200 points
            const chunkSize = 150; // Optimized batch size (still safe for URLs)
            const allResults = [];
            
            console.log(`üåê Processing ${uncachedPoints.length} points in chunks of ${chunkSize}...`);
            
            for (let chunkStart = 0; chunkStart < uncachedPoints.length; chunkStart += chunkSize) {
                const chunkEnd = Math.min(chunkStart + chunkSize, uncachedPoints.length);
                const chunk = uncachedPoints.slice(chunkStart, chunkEnd);
                
                console.log(`üì¶ Batch ${Math.floor(chunkStart/chunkSize) + 1}: Fetching ${chunk.length} points`);
                
                // Create batch request for this chunk
                const locations = chunk.map(p => `${p.lat},${p.lng}`).join('|');
                
                const response = await fetch(
                    `https://api.open-elevation.com/api/v1/lookup?locations=${locations}`,
                    {
                        timeout: 15000,
                        headers: {
                            'Accept': 'application/json'
                        }
                    }
                );
                
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                
                const data = await response.json();
                
                if (data.results && data.results.length > 0) {
                    console.log(`‚úÖ Chunk ${Math.floor(chunkStart/chunkSize) + 1} success: ${data.results.length} results`);
                    
                    // Process this chunk's results
                    for (let i = 0; i < data.results.length; i++) {
                        const result = data.results[i];
                        const originalIndex = uncachedIndices[chunkStart + i];
                        const point = chunk[i];
                        
                        const elevationMeters = result.elevation;
                        const elevationFeet = elevationMeters * 3.28084;
                        const finalElevation = Math.max(0, elevationFeet);
                        
                        // Cache the result
                        const cacheKey = `${point.lat.toFixed(5)},${point.lng.toFixed(5)}`;
                        this.elevationCache.set(cacheKey, finalElevation);
                        
                        // Store in results array
                        cachedResults[originalIndex] = finalElevation;
                    }
                } else {
                    throw new Error(`No elevation data in chunk ${Math.floor(chunkStart/chunkSize) + 1} response`);
                }
                
                // Small delay between chunks to be API-friendly
                if (chunkEnd < uncachedPoints.length) {
                    await new Promise(resolve => setTimeout(resolve, 100));
                }
            }
            
            console.log(`‚úÖ All ${Math.ceil(uncachedPoints.length/chunkSize)} batch chunks completed successfully`);
            return cachedResults;
            
        } catch (error) {
            console.warn(`‚ö†Ô∏è Batch elevation API failed:`, error.message);
            
            // Fallback to individual requests for uncached points
            console.log('üîÑ Falling back to individual elevation requests...');
            
            for (let i = 0; i < uncachedPoints.length; i++) {
                const point = uncachedPoints[i];
                const originalIndex = uncachedIndices[i];
                
                try {
                    const elevation = await this.getElevationForPoint(point.lat, point.lng);
                    cachedResults[originalIndex] = elevation;
                } catch (err) {
                    console.warn(`‚ö†Ô∏è Individual elevation failed for ${point.lat}, ${point.lng}`);
                    cachedResults[originalIndex] = this.getFallbackElevation(point.lat, point.lng);
                }
            }
            
            // Show fallback indicator if we had to use it
            this.showElevationDataSource(false);
            
            return cachedResults;
        }
    }

    async getElevationForPoint(lat, lng) {
        // Create cache key (round to ~1m precision for better accuracy)
        const cacheKey = `${lat.toFixed(5)},${lng.toFixed(5)}`;
        
        // Check cache first
        if (this.elevationCache.has(cacheKey)) {
            console.log(`üìã Using cached elevation for ${cacheKey}`);
            return this.elevationCache.get(cacheKey);
        }
        
        try {
            // Use Open-Elevation API for real elevation data
            console.log(`üèîÔ∏è Getting real elevation for ${lat.toFixed(6)}, ${lng.toFixed(6)}`);
            
            const response = await fetch(
                `https://api.open-elevation.com/api/v1/lookup?locations=${lat},${lng}`,
                { 
                    timeout: 8000, // Increased timeout for better reliability
                    headers: {
                        'Accept': 'application/json'
                    }
                }
            );
            
            if (!response.ok) {
                throw new Error(`HTTP ${response.status}: ${response.statusText}`);
            }
            
            const data = await response.json();
            
            if (data.results && data.results.length > 0) {
                const elevationMeters = data.results[0].elevation;
                const elevationFeet = elevationMeters * 3.28084; // Convert meters to feet
                const finalElevation = Math.max(0, elevationFeet); // Ensure non-negative
                
                console.log(`‚úÖ Real elevation: ${elevationMeters}m = ${finalElevation.toFixed(1)}ft`);
                
                // Cache the result
                this.elevationCache.set(cacheKey, finalElevation);
                
                return finalElevation;
            } else {
                throw new Error('No elevation data in response');
            }
            
        } catch (error) {
            console.warn(`‚ö†Ô∏è Elevation API failed for ${lat}, ${lng}:`, error.message);
            
            // Fallback to reasonable mock data if API fails
            const fallbackElevation = this.getFallbackElevation(lat, lng);
            
            // Cache the fallback too (but don't overwrite real data)
            if (!this.elevationCache.has(cacheKey)) {
                this.elevationCache.set(cacheKey, fallbackElevation);
            }
            
            return fallbackElevation;
        }
    }
    
    getFallbackElevation(lat, lng) {
        // Fallback elevation when API is unavailable
        // Use more conservative mock data
        console.log('üîÑ Using fallback elevation calculation');
        
        // Rough elevation based on latitude (very approximate)
        let baseElevation = 300; // Default sea level + a bit
        
        // Very rough continental elevation estimates
        if (lat > 35 && lat < 50 && lng > -125 && lng < -70) {
            // Rough USA - varies by region
            if (lng > -105) baseElevation = 800; // Eastern US - rolling hills
            else if (lng > -115) baseElevation = 3000; // Rocky Mountains area
            else baseElevation = 500; // Western coastal
        } else if (lat > 45 && lat < 70 && lng > -140 && lng < -50) {
            // Rough Canada
            baseElevation = 600;
        } else if (lat > 25 && lat < 50 && lng > -10 && lng < 30) {
            // Rough Europe
            baseElevation = 400;
        }
        
        // Add some variation but keep it realistic
        const variation = Math.sin(lat * 0.1) * Math.cos(lng * 0.1) * 300;
        return Math.max(0, Math.min(8000, baseElevation + variation));
    }

    calculateElevationStats(routeData) {
        if (!routeData || routeData.length === 0) {
            return {
                totalGain: 0,
                totalLoss: 0,
                maxElevation: 0,
                minElevation: 0,
                avgGrade: 0,
                climbs: []
            };
        }
        
        let totalGain = 0;
        let totalLoss = 0;
        let maxElevation = -Infinity;
        let minElevation = Infinity;
        let uphillDistance = 0;
        let downhillDistance = 0;
        let totalUphillGrade = 0;
        let totalDownhillGrade = 0;
        
        // Include first point for min/max
        maxElevation = routeData[0].elevation;
        minElevation = routeData[0].elevation;
        
        // Minimum elevation change threshold (ignore tiny changes)
        const MIN_ELEV_CHANGE = 3; // feet - filters out noise
        
        // Track climbs for categorization
        const climbs = [];
        let currentClimb = null;
        
        for (let i = 1; i < routeData.length; i++) {
            const elevChange = routeData[i].elevation - routeData[i - 1].elevation;
            const distance = routeData[i].distance - routeData[i - 1].distance;
            
            // Only count significant elevation changes
            if (Math.abs(elevChange) >= MIN_ELEV_CHANGE) {
                if (elevChange > 0) {
                    totalGain += elevChange;
                    uphillDistance += distance;
                    totalUphillGrade += Math.abs(routeData[i].grade) * distance;
                    
                    // Track climb segments
                    if (!currentClimb && routeData[i].grade > 3) {
                        currentClimb = {
                            startIndex: i - 1,
                            startDistance: routeData[i - 1].distance,
                            startElevation: routeData[i - 1].elevation,
                            maxGrade: routeData[i].grade
                        };
                    } else if (currentClimb) {
                        currentClimb.maxGrade = Math.max(currentClimb.maxGrade, routeData[i].grade);
                    }
                } else {
                    totalLoss += Math.abs(elevChange);
                    downhillDistance += distance;
                    totalDownhillGrade += Math.abs(routeData[i].grade) * distance;
                    
                    // End climb if descending
                    if (currentClimb && routeData[i].grade < 1) {
                        currentClimb.endIndex = i;
                        currentClimb.endDistance = routeData[i].distance;
                        currentClimb.endElevation = routeData[i].elevation;
                        currentClimb.totalGain = currentClimb.endElevation - currentClimb.startElevation;
                        currentClimb.distance = (currentClimb.endDistance - currentClimb.startDistance) * 5280; // feet
                        currentClimb.avgGrade = (currentClimb.totalGain / currentClimb.distance) * 100;
                        
                        // Only include significant climbs
                        if (currentClimb.totalGain > 50) { // 50+ feet of climbing
                            climbs.push(this.categorizeClimb(currentClimb));
                        }
                        currentClimb = null;
                    }
                }
            }
            
            maxElevation = Math.max(maxElevation, routeData[i].elevation);
            minElevation = Math.min(minElevation, routeData[i].elevation);
        }
        
        // Handle climb that extends to end of route
        if (currentClimb) {
            currentClimb.endIndex = routeData.length - 1;
            currentClimb.endDistance = routeData[routeData.length - 1].distance;
            currentClimb.endElevation = routeData[routeData.length - 1].elevation;
            currentClimb.totalGain = currentClimb.endElevation - currentClimb.startElevation;
            currentClimb.distance = (currentClimb.endDistance - currentClimb.startDistance) * 5280;
            currentClimb.avgGrade = (currentClimb.totalGain / currentClimb.distance) * 100;
            
            if (currentClimb.totalGain > 50) {
                climbs.push(this.categorizeClimb(currentClimb));
            }
        }
        
        // Calculate weighted average grade (weighted by distance)
        const totalClimbingDistance = uphillDistance + downhillDistance;
        const avgGrade = totalClimbingDistance > 0 
            ? (totalUphillGrade + totalDownhillGrade) / totalClimbingDistance
            : 0;
        
        return {
            totalGain: Math.round(totalGain),
            totalLoss: Math.round(totalLoss),
            maxElevation: Math.round(maxElevation),
            minElevation: Math.round(minElevation),
            avgGrade: Math.round(avgGrade * 10) / 10, // Round to 1 decimal
            climbs: climbs
        };
    }

    createElevationChart(routeData) {
        const ctx = document.getElementById('elevationChart').getContext('2d');
        
        // Destroy existing chart if it exists
        if (this.elevationChart) {
            this.elevationChart.destroy();
        }
        
        // Prepare data for Chart.js with proper x,y coordinates
        const chartData = {
            datasets: [{
                label: 'Elevation',
                data: routeData.map(point => ({
                    x: point.distance,
                    y: point.elevation
                })),
                borderColor: '#5865f2',
                backgroundColor: (context) => {
                    const ctx = context.chart.ctx;
                    const gradient = ctx.createLinearGradient(0, 0, 0, 120);
                    gradient.addColorStop(0, 'rgba(88, 101, 242, 0.4)');
                    gradient.addColorStop(1, 'rgba(88, 101, 242, 0.0)');
                    return gradient;
                },
                fill: true,
                tension: 0.1, // Reduced tension for more accurate profile
                pointRadius: 0,
                pointHoverRadius: 5,
                pointBackgroundColor: '#5865f2',
                pointBorderColor: '#fff',
                pointBorderWidth: 2,
                segment: {
                    borderColor: (ctx) => this.getSegmentColor(ctx, routeData)
                }
            }]
        };
        
        // Create new chart
        this.elevationChart = new Chart(ctx, {
            type: 'line',
            data: chartData,
            options: {
                responsive: true,
                maintainAspectRatio: false,
                interaction: {
                    mode: 'index',
                    intersect: false
                },
                plugins: {
                    legend: {
                        display: false
                    },
                    tooltip: {
                        enabled: false // We'll use custom tooltip
                    }
                },
                scales: {
                    x: {
                        type: 'linear',
                        display: true,
                        grid: {
                            color: 'rgba(255, 255, 255, 0.05)'
                        },
                        ticks: {
                            color: '#b9bbbe',
                            maxRotation: 0,
                            callback: function(value) {
                                return value.toFixed(1) + ' mi';
                            }
                        },
                        title: {
                            display: false
                        }
                    },
                    y: {
                        display: true,
                        grid: {
                            color: 'rgba(255, 255, 255, 0.05)'
                        },
                        ticks: {
                            color: '#b9bbbe',
                            callback: function(value) {
                                return Math.round(value) + ' ft';
                            }
                        }
                    }
                },
                onHover: (event, activeElements) => {
                    this.handleChartHover(event, activeElements, routeData);
                },
                plugins: {
                    zoom: {
                        zoom: {
                            wheel: {
                                enabled: true,
                                modifierKey: 'ctrl'
                            },
                            pinch: {
                                enabled: true
                            },
                            mode: 'x',
                            onZoom: () => {
                                this.showChartZoomControls();
                            }
                        },
                        pan: {
                            enabled: true,
                            mode: 'x',
                            modifierKey: 'shift'
                        }
                    }
                }
            }
        });
        
        // Add canvas event listeners for custom tooltip
        const canvas = document.getElementById('elevationChart');
        canvas.addEventListener('mouseleave', () => {
            document.getElementById('elevationTooltip').style.display = 'none';
        });
        
        // Add zoom/pan controls
        this.addChartControls();
    }
    
    addChartControls() {
        // Remove existing controls
        const existingControls = document.querySelector('.chart-controls');
        if (existingControls) existingControls.remove();
        
        const controls = document.createElement('div');
        controls.className = 'chart-controls';
        controls.style.cssText = `
            position: absolute;
            top: 8px;
            right: 8px;
            display: flex;
            gap: 4px;
            z-index: 10;
        `;
        
        // Export button
        const exportBtn = document.createElement('button');
        exportBtn.innerHTML = 'üì∑';
        exportBtn.title = 'Export elevation profile';
        exportBtn.style.cssText = `
            width: 28px;
            height: 28px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            background: rgba(0, 0, 0, 0.5);
            color: white;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            display: flex;
            align-items: center;
            justify-content: center;
        `;
        exportBtn.onclick = () => this.exportElevationProfile();
        
        // Reset zoom button
        const resetBtn = document.createElement('button');
        resetBtn.innerHTML = '‚ü≤';
        resetBtn.title = 'Reset zoom';
        resetBtn.style.cssText = `
            width: 28px;
            height: 28px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            background: rgba(0, 0, 0, 0.5);
            color: white;
            border-radius: 4px;
            cursor: pointer;
            font-size: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        `;
        resetBtn.onclick = () => {
            if (this.elevationChart) {
                this.elevationChart.resetZoom();
            }
        };
        
        // Instructions
        const instructions = document.createElement('div');
        instructions.style.cssText = `
            font-size: 0.7rem;
            color: var(--text-secondary);
            padding: 4px 8px;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 4px;
            display: flex;
            align-items: center;
        `;
        instructions.innerHTML = 'Ctrl+Scroll to zoom ‚Ä¢ Shift+Drag to pan';
        
        controls.appendChild(exportBtn);
        controls.appendChild(resetBtn);
        controls.appendChild(instructions);
        
        const chartContainer = document.getElementById('profileChartContainer');
        chartContainer.appendChild(controls);
    }
    
    exportElevationProfile() {
        if (!this.elevationChart) return;
        
        // Create a temporary canvas with better resolution
        const originalCanvas = document.getElementById('elevationChart');
        const tempCanvas = document.createElement('canvas');
        const scaleFactor = 2; // Higher resolution
        
        tempCanvas.width = originalCanvas.width * scaleFactor;
        tempCanvas.height = originalCanvas.height * scaleFactor;
        
        const tempCtx = tempCanvas.getContext('2d');
        tempCtx.scale(scaleFactor, scaleFactor);
        
        // White background
        tempCtx.fillStyle = 'white';
        tempCtx.fillRect(0, 0, originalCanvas.width, originalCanvas.height);
        
        // Draw the chart
        const chartImage = originalCanvas.toDataURL('image/png');
        const img = new Image();
        img.onload = () => {
            tempCtx.drawImage(img, 0, 0, originalCanvas.width, originalCanvas.height);
            
            // Add title and stats
            tempCtx.fillStyle = 'black';
            tempCtx.font = 'bold 16px Arial';
            tempCtx.fillText('Elevation Profile', 10, 20);
            
            tempCtx.font = '12px Arial';
            const stats = [
                `Distance: ${document.getElementById('routeDistance').textContent} mi`,
                `Elevation Gain: ${document.getElementById('routeElevation').textContent}`,
                `Max: ${document.getElementById('elevationMax').textContent}`,
                `Avg Grade: ${document.getElementById('avgGrade').textContent}`
            ];
            
            stats.forEach((stat, i) => {
                tempCtx.fillText(stat, 10, 40 + i * 15);
            });
            
            // Download the image
            tempCanvas.toBlob((blob) => {
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `elevation-profile-${new Date().toISOString().slice(0, 10)}.png`;
                a.click();
                URL.revokeObjectURL(url);
                
                this.showNotification('Elevation profile exported!', 'success');
            }, 'image/png');
        };
        img.src = chartImage;
    }

    getSegmentColor(ctx, routeData) {
        const index = ctx.p1DataIndex;
        if (index < routeData.length) {
            const grade = routeData[index].grade;
            if (grade < -3) return '#10b981'; // Descent - green
            if (grade > 7) return '#ef4444';   // Steep - red
            if (grade > 3) return '#f59e0b';   // Moderate - orange
            return '#6b7280';                  // Flat - gray
        }
        return '#5865f2';
    }

    handleChartHover(event, activeElements, routeData) {
        const tooltip = document.getElementById('elevationTooltip');
        
        if (activeElements.length > 0) {
            const index = activeElements[0].index;
            const point = routeData[index];
            
            // Update tooltip content
            tooltip.querySelector('.tooltip-distance span').textContent = `${point.distance.toFixed(2)} mi`;
            tooltip.querySelector('.tooltip-elevation span').textContent = `${Math.round(point.elevation)} ft`;
            tooltip.querySelector('.tooltip-grade span').textContent = `${point.grade.toFixed(1)}%`;
            
            // Position tooltip
            const rect = event.native.target.getBoundingClientRect();
            const x = event.native.offsetX;
            const y = event.native.offsetY;
            
            tooltip.style.display = 'block';
            tooltip.style.left = `${x + 10}px`;
            tooltip.style.top = `${y - 50}px`;
            
            // Add marker on map if exists
            if (this.elevationMarker) {
                this.map.removeLayer(this.elevationMarker);
            }
            this.elevationMarker = L.circleMarker([point.lat, point.lng], {
                radius: 6,
                fillColor: '#5865f2',
                color: '#fff',
                weight: 2,
                fillOpacity: 1
            }).addTo(this.map);
        } else {
            tooltip.style.display = 'none';
            if (this.elevationMarker) {
                this.map.removeLayer(this.elevationMarker);
                this.elevationMarker = null;
            }
        }
    }

    hideElevationProfile() {
        // Don't hide the container, just show the no route message
        this.showNoRouteMessage();
        if (this.elevationChart) {
            this.elevationChart.destroy();
            this.elevationChart = null;
        }
    }
    
    showNoRouteMessage() {
        document.getElementById('noRouteMessage').style.display = 'block';
        document.getElementById('elevationChart').style.display = 'none';
        document.getElementById('elevationStats').style.display = 'none';
        document.getElementById('elevationLegend').style.display = 'none';
        
        // Clear stats
        document.getElementById('elevationMax').textContent = '-- ft';
        document.getElementById('elevationMin').textContent = '-- ft';
        document.getElementById('avgGrade').textContent = '--%';
    }

    analyzeCurves(route) {
        // Analyze route for curves and twisty sections
        const coordinates = route.coordinates;
        let curveCount = 0;
        
        for (let i = 2; i < coordinates.length; i++) {
            const angle = this.calculateAngle(coordinates[i-2], coordinates[i-1], coordinates[i]);
            if (Math.abs(angle) > 30) { // Significant direction change
                curveCount++;
            }
        }
        
        document.getElementById('routeCurves').textContent = curveCount;
    }

    calculateAngle(p1, p2, p3) {
        const angle1 = Math.atan2(p2.lat - p1.lat, p2.lng - p1.lng);
        const angle2 = Math.atan2(p3.lat - p2.lat, p3.lng - p2.lng);
        return ((angle2 - angle1) * 180 / Math.PI + 360) % 360;
    }

    estimateSurfaceTypes(route) {
        // Mock surface analysis - in real implementation, analyze road types
        const pavedPercent = Math.floor(Math.random() * 30 + 70);
        const gravelPercent = Math.floor(Math.random() * 20 + 5);
        const dirtPercent = 100 - pavedPercent - gravelPercent;
        
        document.getElementById('pavedPercent').textContent = `${pavedPercent}%`;
        document.getElementById('gravelPercent').textContent = `${gravelPercent}%`;
        document.getElementById('dirtPercent').textContent = `${dirtPercent}%`;
    }

    async reverseGeocode(latlng) {
        try {
            const response = await fetch(`https://nominatim.openstreetmap.org/reverse?format=json&lat=${latlng.lat}&lon=${latlng.lng}`);
            const data = await response.json();
            return data.display_name || 'Unknown location';
        } catch (error) {
            console.error('Geocoding error:', error);
            return `${latlng.lat.toFixed(6)}, ${latlng.lng.toFixed(6)}`;
        }
    }

    clearRoute() {
        console.log('üßπ Clearing route...');
        
        // Clear waypoint markers
        this.waypoints.forEach(marker => this.map.removeLayer(marker));
        this.waypoints = [];
        
        // Clear POI markers
        this.pois.forEach(poi => this.map.removeLayer(poi.marker));
        this.pois = [];
        
        // Clear route line
        if (this.routeLine) {
            this.map.removeLayer(this.routeLine);
            this.routeLine = null;
        }
        
        // Clear routing control
        if (this.routingControl) {
            this.routingControl.setWaypoints([]);
        }
        
        this.clearRouteDisplay();
        
        // Reset waypoint mode and UI
        this.waypointMode = false;
        this.insertAfterIndex = undefined;
        const waypointBtn = document.getElementById('addWaypointMode');
        waypointBtn.classList.remove('active');
        waypointBtn.querySelector('.waypoint-text').textContent = 'Click to Add Waypoints';
        this.map.getContainer().style.cursor = '';
        
        // Update instruction text
        this.updateWaypointUI();
        
        console.log('‚úÖ Route cleared');
    }

    clearRouteDisplay() {
        document.getElementById('routeDistance').textContent = '0';
        document.getElementById('routeTime').textContent = '0h 0m';
        document.getElementById('routeElevation').textContent = '0 ft';
        document.getElementById('elevationLost').textContent = '0 ft';
        document.getElementById('routeCurves').textContent = '0';
        document.getElementById('pavedPercent').textContent = '0%';
        document.getElementById('gravelPercent').textContent = '0%';
        document.getElementById('dirtPercent').textContent = '0%';
        
        // Hide elevation profile
        this.hideElevationProfile();
    }

    makeLoop() {
        if (this.waypoints.length >= 2) {
            const firstPoint = this.waypoints[0].getLatLng();
            this.addWaypoint(firstPoint);
        }
    }

    makeRoundTrip() {
        if (this.waypoints.length >= 2) {
            // Reverse the waypoints to create a round trip
            const reversePoints = [...this.waypoints].reverse().slice(1); // Skip the last point to avoid duplicate
            reversePoints.forEach(marker => {
                this.addWaypoint(marker.getLatLng());
            });
        }
    }

    async saveRoute() {
        if (this.waypoints.length < 2) {
            this.showNotification('Please add at least 2 waypoints to save a route', 'warning');
            return;
        }
        
        const routeName = prompt('Enter route name:');
        if (!routeName) return;
        
        const routeData = {
            id: Date.now().toString(),
            name: routeName,
            waypoints: this.waypoints.map(marker => marker.getLatLng()),
            pois: this.pois.map(poi => ({ type: poi.type, latlng: poi.latlng })),
            preferences: { ...this.preferences },
            stats: this.currentRoute ? {
                distance: this.currentRoute.summary.totalDistance,
                time: this.currentRoute.summary.totalTime
            } : null,
            created: new Date().toISOString()
        };
        
        // Save to localStorage
        const savedRoutes = JSON.parse(localStorage.getItem('bikenode_routes') || '[]');
        savedRoutes.push(routeData);
        localStorage.setItem('bikenode_routes', JSON.stringify(savedRoutes));
        
        this.showNotification('Route saved successfully!', 'success');
    }

    shareRoute() {
        if (this.waypoints.length < 2) {
            this.showNotification('Please create a route to share', 'warning');
            return;
        }
        
        const routeData = {
            waypoints: this.waypoints.map(marker => marker.getLatLng()),
            pois: this.pois.map(poi => ({ type: poi.type, latlng: poi.latlng }))
        };
        
        const routeUrl = `${window.location.origin}/route-planner?data=${encodeURIComponent(JSON.stringify(routeData))}`;
        
        if (navigator.share) {
            navigator.share({
                title: 'BikeNode Route',
                url: routeUrl
            });
        } else {
            navigator.clipboard.writeText(routeUrl);
            this.showNotification('Route URL copied to clipboard!', 'success');
        }
    }

    exportRoute() {
        if (this.waypoints.length < 2) {
            this.showNotification('Please create a route to export', 'warning');
            return;
        }
        
        const routeName = prompt('Enter route name:', 'BikeNode Route') || 'BikeNode Route';
        const currentDate = new Date().toISOString();
        
        // Create GPX content with full route coordinates
        let gpx = `<?xml version="1.0" encoding="UTF-8"?>
<gpx version="1.1" creator="BikeNode Route Planner" xmlns="http://www.topografix.com/GPX/1/1">
  <metadata>
    <name>${routeName}</name>
    <desc>Route created with BikeNode Route Planner</desc>
    <time>${currentDate}</time>
    <author>
      <name>BikeNode</name>
    </author>
  </metadata>`;

        // Add track with full route coordinates if available
        if (this.currentRoute && this.currentRoute.coordinates && this.currentRoute.coordinates.length > 0) {
            gpx += `
  <trk>
    <name>${routeName}</name>
    <desc>Full route track following roads/trails</desc>
    <trkseg>`;
            
            this.currentRoute.coordinates.forEach(coord => {
                gpx += `
      <trkpt lat="${coord.lat}" lon="${coord.lng}"></trkpt>`;
            });
            
            gpx += `
    </trkseg>
  </trk>`;
        } else {
            // Fallback to waypoints only if no route calculated
            gpx += `
  <trk>
    <name>${routeName}</name>
    <desc>Waypoint track</desc>
    <trkseg>`;
            
            this.waypoints.forEach(marker => {
                const ll = marker.getLatLng();
                gpx += `
      <trkpt lat="${ll.lat}" lon="${ll.lng}"></trkpt>`;
            });
            
            gpx += `
    </trkseg>
  </trk>`;
        }
        
        // Add waypoints as route points for navigation
        gpx += `
  <rte>
    <name>${routeName} - Waypoints</name>`;
        
        this.waypoints.forEach((marker, i) => {
            const ll = marker.getLatLng();
            gpx += `
    <rtept lat="${ll.lat}" lon="${ll.lng}">
      <name>Waypoint ${String.fromCharCode(65 + i)}</name>
      <desc>Stop ${i + 1}</desc>
    </rtept>`;
        });
        
        gpx += `
  </rte>`;
        
        // Add POIs as waypoints
        if (this.pois.length > 0) {
            this.pois.forEach((poi, i) => {
                const poiNames = {
                    gas: 'Gas Station',
                    food: 'Food Stop',
                    scenic: 'Scenic Viewpoint',
                    mechanic: 'Bike Shop'
                };
                gpx += `
  <wpt lat="${poi.latlng.lat}" lon="${poi.latlng.lng}">
    <name>${poiNames[poi.type] || poi.type} ${i + 1}</name>
    <desc>${poiNames[poi.type] || poi.type}</desc>
    <type>${poi.type}</type>
  </wpt>`;
            });
        }
        
        gpx += `
</gpx>`;
        
        // Download GPX file
        const fileName = `${routeName.replace(/[^a-z0-9]/gi, '_').toLowerCase()}_route.gpx`;
        const blob = new Blob([gpx], { type: 'application/gpx+xml' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = fileName;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
        
        this.showNotification(`Route exported as ${fileName}!`, 'success');
    }

    recalculateRoute() {
        if (this.waypoints.length >= 2) {
            console.log('üîÑ Recalculating route with updated preferences...');
            // Update router with current preferences before recalculating
            if (this.routingControl) {
                // Create new router with updated options
                const newRouter = this.createRouter();
                this.routingControl.options.router = newRouter;
                
                // Force route recalculation by setting waypoints again
                const currentWaypoints = this.waypoints.map(marker => marker.getLatLng());
                this.routingControl.setWaypoints(currentWaypoints);
            }
        }
    }

    loadUserLocation() {
        if (navigator.geolocation) {
            navigator.geolocation.getCurrentPosition(
                (position) => {
                    const { latitude, longitude } = position.coords;
                    this.map.setView([latitude, longitude], 13);
                    
                    // Store user location for later use
                    this.userLocation = L.latLng(latitude, longitude);
                    
                    // Add user location marker
                    L.marker([latitude, longitude], {
                        icon: L.divIcon({
                            className: 'user-location-marker',
                            html: '<div style="background: #007bff; width: 16px; height: 16px; border-radius: 50%; border: 3px solid white; box-shadow: 0 0 10px rgba(0,123,255,0.5);"></div>',
                            iconSize: [16, 16],
                            iconAnchor: [8, 8]
                        })
                    }).addTo(this.map).bindPopup('Your Location');
                },
                (error) => {
                    console.warn('Geolocation error:', error);
                }
            );
        }
    }

    useMyLocationAsStart() {
        console.log('useMyLocationAsStart called');
        console.log('Current userLocation:', this.userLocation);
        console.log('Geolocation available:', 'geolocation' in navigator);
        
        if (this.userLocation) {
            // Center map on user location and add as first waypoint
            this.map.setView([this.userLocation.lat, this.userLocation.lng], 15);
            this.addWaypoint(this.userLocation);
            this.showNotification('Added your location as starting point! Click the map to add your destination.', 'success');
        } else {
            // Get location and use it
            if (navigator.geolocation) {
                const button = document.getElementById('useMyLocation');
                console.log('Button element:', button);
                button.textContent = 'üìç Getting location...';
                button.disabled = true;
                
                navigator.geolocation.getCurrentPosition(
                    (position) => {
                        console.log('Geolocation success:', position);
                        const { latitude, longitude } = position.coords;
                        const location = L.latLng(latitude, longitude);
                        this.userLocation = location;
                        this.map.setView([latitude, longitude], 15);
                        this.addWaypoint(location);
                        
                        button.textContent = 'üìç Use My Location';
                        button.disabled = false;
                        
                        this.showNotification('Added your location as starting point! Click the map to add your destination.', 'success');
                    },
                    (error) => {
                        console.error('Geolocation error:', error);
                        console.error('Error code:', error.code);
                        console.error('Error message:', error.message);
                        
                        let errorMessage = 'Could not get your location. ';
                        switch(error.code) {
                            case error.PERMISSION_DENIED:
                                errorMessage += 'Permission denied. Please enable location access.';
                                break;
                            case error.POSITION_UNAVAILABLE:
                                errorMessage += 'Location information unavailable.';
                                break;
                            case error.TIMEOUT:
                                errorMessage += 'Location request timed out.';
                                break;
                            default:
                                errorMessage += 'Please click on the map to add a starting point.';
                        }
                        
                        button.textContent = 'üìç Use My Location';
                        button.disabled = false;
                        this.showNotification(errorMessage, 'warning');
                    },
                    {
                        enableHighAccuracy: true,
                        timeout: 10000,
                        maximumAge: 0
                    }
                );
            } else {
                console.log('Geolocation not supported');
                this.showNotification('Geolocation not supported. Please click on the map to add a starting point.', 'warning');
            }
        }
    }

    loadSavedRoutes() {
        // Check URL for shared route data
        const urlParams = new URLSearchParams(window.location.search);
        const routeData = urlParams.get('data');
        
        if (routeData) {
            try {
                const route = JSON.parse(decodeURIComponent(routeData));
                this.loadRoute(route);
            } catch (error) {
                console.error('Error loading shared route:', error);
            }
        }
    }

    loadRoute(routeData) {
        this.clearRoute();
        
        // Load waypoints
        if (routeData.waypoints) {
            routeData.waypoints.forEach(latlng => {
                this.addWaypoint(L.latLng(latlng.lat, latlng.lng));
            });
        }
        
        // Load POIs
        if (routeData.pois) {
            routeData.pois.forEach(poi => {
                this.addPOI(L.latLng(poi.latlng.lat, poi.latlng.lng), poi.type);
            });
        }
        
        // Fit map to route
        if (this.waypoints.length > 0) {
            const group = new L.featureGroup(this.waypoints);
            this.map.fitBounds(group.getBounds().pad(0.1));
        }
    }

    makeRouteClickable() {
        // Make the route line clickable to add waypoints - Strava-like feature
        // This is handled by the routing control's addWaypoints: true option
        console.log('Route is now clickable for adding waypoints');
    }
    
    syncWaypoints(routingWaypoints) {
        // Sync our custom waypoint markers with the routing control waypoints
        // This ensures our lettered markers stay in sync when waypoints are added via route clicking
        console.log('Syncing waypoints:', routingWaypoints);
        
        // Clear existing waypoint markers
        this.waypoints.forEach(marker => this.map.removeLayer(marker));
        this.waypoints = [];
        
        // Recreate waypoint markers for each routing waypoint
        routingWaypoints.forEach((waypoint, index) => {
            if (waypoint.latLng) {
                this.addWaypointMarker(waypoint.latLng, index);
            }
        });
    }
    
    addWaypointMarker(latlng, index) {
        const letter = String.fromCharCode(65 + index);
        
        const marker = L.marker(latlng, {
            draggable: true,
            icon: L.divIcon({
                className: 'waypoint-marker',
                html: `<div style="background: var(--accent); color: white; width: 30px; height: 30px; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-weight: bold; border: 3px solid white; box-shadow: 0 2px 8px rgba(88, 101, 242, 0.4); cursor: move;">${letter}</div>`,
                iconSize: [30, 30],
                iconAnchor: [15, 15]
            })
        }).addTo(this.map);

        // Add drag event that updates the routing control
        marker.on('drag', () => {
            const newWaypoints = this.waypoints.map(m => m.getLatLng());
            this.routingControl.setWaypoints(newWaypoints);
        });

        // Add popup with waypoint info
        marker.bindPopup(`
            <div style="text-align: center;">
                <strong>Waypoint ${letter}</strong><br>
                <button onclick="routePlanner.removeWaypointByIndex(${index})" style="margin-top: 8px; padding: 6px 12px; background: #ef4444; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 12px;">Remove</button>
            </div>
        `);

        this.waypoints[index] = marker;
        return marker;
    }
    
    removeWaypointByIndex(index) {
        // Remove waypoint by index and update routing
        if (this.waypoints[index]) {
            this.map.removeLayer(this.waypoints[index]);
            this.waypoints.splice(index, 1);
            
            // Update routing control
            const newWaypoints = this.waypoints.map(marker => marker.getLatLng());
            this.routingControl.setWaypoints(newWaypoints);
            
            // Re-label remaining waypoints
            this.relabelWaypoints();
        }
    }
    
    relabelWaypoints() {
        // Update waypoint labels after removal
        this.waypoints.forEach((marker, index) => {
            const letter = String.fromCharCode(65 + index);
            marker.setIcon(L.divIcon({
                className: 'waypoint-marker',
                html: `<div style="background: var(--accent); color: white; width: 30px; height: 30px; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-weight: bold; border: 3px solid white; box-shadow: 0 2px 8px rgba(88, 101, 242, 0.4); cursor: move;">${letter}</div>`,
                iconSize: [30, 30],
                iconAnchor: [15, 15]
            }));
            
            // Update popup content
            marker.setPopupContent(`
                <div style="text-align: center;">
                    <strong>Waypoint ${letter}</strong><br>
                    <button onclick="routePlanner.removeWaypointByIndex(${index})" style="margin-top: 8px; padding: 6px 12px; background: #ef4444; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 12px;">Remove</button>
                </div>
            `);
        });
    }

    // Geocoding for address input
    async geocodeAndAddWaypoint(address) {
        if (!address.trim()) return;
        
        try {
            const response = await fetch(`https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(address)}`);
            const data = await response.json();
            
            if (data.length > 0) {
                const result = data[0];
                const latlng = L.latLng(result.lat, result.lon);
                this.addWaypoint(latlng);
                this.map.setView(latlng, 13);
                document.getElementById('startPointInput').value = '';
                this.showNotification(`Added waypoint: ${result.display_name}`, 'success');
            } else {
                this.showNotification('Location not found. Try a different address.', 'warning');
            }
        } catch (error) {
            console.error('Geocoding error:', error);
            this.showNotification('Error finding location', 'error');
        }
    }
    
    // Toggle manual mode
    toggleManualMode(enabled) {
        if (enabled) {
            this.showNotification('Manual mode enabled - click route to add waypoints', 'info');
            this.routingControl.options.addWaypoints = true;
        } else {
            this.routingControl.options.addWaypoints = false;
        }
    }
    
    // Toggle surface type display
    toggleSurfaceDisplay(show) {
        if (show && this.currentRoute) {
            this.showSurfaceTypes();
        } else if (this.surfaceOverlay) {
            this.map.removeLayer(this.surfaceOverlay);
        }
    }
    
    // Show surface types on map
    showSurfaceTypes() {
        if (!this.currentRoute || !this.currentRoute.coordinates) return;
        
        // Create colored segments based on surface type
        // This is a simplified version - real implementation would need actual surface data
        const segments = [];
        const colors = {
            paved: '#10b981',
            gravel: '#f59e0b',
            trail: '#8b5cf6'
        };
        
        // For demo purposes, randomly assign surface types to route segments
        for (let i = 0; i < this.currentRoute.coordinates.length - 1; i += 10) {
            const start = i;
            const end = Math.min(i + 10, this.currentRoute.coordinates.length - 1);
            const coords = this.currentRoute.coordinates.slice(start, end + 1).map(c => [c.lat, c.lng]);
            
            const surfaceType = ['paved', 'gravel', 'trail'][Math.floor(Math.random() * 3)];
            const segment = L.polyline(coords, {
                color: colors[surfaceType],
                weight: 8,
                opacity: 0.6
            });
            segments.push(segment);
        }
        
        this.surfaceOverlay = L.layerGroup(segments).addTo(this.map);
    }
    
    // Toggle distance markers
    toggleDistanceMarkers(show) {
        if (show && this.currentRoute) {
            this.addDistanceMarkers();
        } else {
            this.distanceMarkers.forEach(marker => this.map.removeLayer(marker));
            this.distanceMarkers = [];
        }
    }
    
    // Add distance markers along route
    addDistanceMarkers() {
        if (!this.currentRoute) return;
        
        const totalDistance = this.currentRoute.summary.totalDistance;
        const markerInterval = 1609.34; // 1 mile in meters
        
        let accumulatedDistance = 0;
        let mileCount = 1;
        
        for (let i = 1; i < this.currentRoute.coordinates.length; i++) {
            const prevCoord = this.currentRoute.coordinates[i - 1];
            const currCoord = this.currentRoute.coordinates[i];
            
            const segmentDistance = this.calculateDistance(
                [prevCoord.lat, prevCoord.lng],
                [currCoord.lat, currCoord.lng]
            );
            
            accumulatedDistance += segmentDistance;
            
            if (accumulatedDistance >= markerInterval * mileCount) {
                const marker = L.marker([currCoord.lat, currCoord.lng], {
                    icon: L.divIcon({
                        className: 'distance-marker',
                        html: `<div style="background: white; color: #5865f2; padding: 4px 8px; border-radius: 12px; font-weight: bold; font-size: 12px; border: 2px solid #5865f2;">${mileCount} mi</div>`,
                        iconSize: [50, 24],
                        iconAnchor: [25, 12]
                    })
                }).addTo(this.map);
                
                this.distanceMarkers.push(marker);
                mileCount++;
            }
        }
    }
    
    // Calculate distance between two points
    calculateDistance(latlng1, latlng2) {
        const R = 6371000; // Earth's radius in meters
        const lat1 = latlng1[0] * Math.PI / 180;
        const lat2 = latlng2[0] * Math.PI / 180;
        const deltaLat = (latlng2[0] - latlng1[0]) * Math.PI / 180;
        const deltaLng = (latlng2[1] - latlng1[1]) * Math.PI / 180;
        
        const a = Math.sin(deltaLat / 2) * Math.sin(deltaLat / 2) +
                  Math.cos(lat1) * Math.cos(lat2) *
                  Math.sin(deltaLng / 2) * Math.sin(deltaLng / 2);
        const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
        
        return R * c;
    }
    
    // Toggle heatmap display
    toggleHeatmaps(show) {
        if (show) {
            this.showHeatmap();
        } else if (this.heatmapLayer) {
            this.map.removeLayer(this.heatmapLayer);
        }
    }
    
    // Show popular routes heatmap
    async showHeatmap() {
        try {
            const bounds = this.map.getBounds();
            const params = new URLSearchParams({
                min_lat: bounds.getSouth().toString(),
                max_lat: bounds.getNorth().toString(),
                min_lng: bounds.getWest().toString(),
                max_lng: bounds.getEast().toString(),
                type: 'road', // Default to road cycling
                period: 'all'
            });

            const response = await fetch(`/api/heatmap?${params}`);
            if (!response.ok) {
                throw new Error('Failed to load heatmap data');
            }

            const heatmapData = await response.json();
            
            if (heatmapData.points && heatmapData.points.length > 0) {
                // Create heatmap using Leaflet.heat plugin
                const heatPoints = heatmapData.points.map(point => [
                    point.lat, 
                    point.lng, 
                    Math.min(point.weight / 10, 1) // Normalize weight
                ]);

                // Remove existing heatmap
                if (this.heatmapLayer) {
                    this.map.removeLayer(this.heatmapLayer);
                }

                // Add new heatmap layer
                this.heatmapLayer = L.heatLayer(heatPoints, {
                    radius: 25,
                    blur: 15,
                    maxZoom: 15,
                    max: 1,
                    gradient: {
                        0.4: 'blue',
                        0.6: 'cyan',
                        0.7: 'lime',
                        0.8: 'yellow',
                        1.0: 'red'
                    }
                }).addTo(this.map);

                this.showNotification(`Showing heatmap with ${heatmapData.points.length} data points`, 'success');
            } else {
                // Fallback to simple overlay if no data
                this.heatmapLayer = L.rectangle(bounds, {
                    color: '#ff6b6b',
                    weight: 0,
                    fillOpacity: 0.1,
                    interactive: false
                }).addTo(this.map);
                
                this.showNotification('No heatmap data available for this area', 'info');
            }
        } catch (error) {
            console.error('Error loading heatmap:', error);
            this.showNotification('Failed to load heatmap data', 'error');
        }
    }
    
    // Toggle segments display
    toggleSegments(show) {
        if (show) {
            this.showSegments();
        } else if (this.segmentsLayer) {
            this.map.removeLayer(this.segmentsLayer);
        }
    }
    
    // Show Strava-like segments
    async showSegments() {
        try {
            const center = this.map.getCenter();
            const params = new URLSearchParams({
                lat: center.lat.toString(),
                lng: center.lng.toString(),
                radius: '16093', // 10 miles in meters
                type: '' // Show all segment types
            });

            const response = await fetch(`/api/segments/nearby?${params}`);
            if (!response.ok) {
                throw new Error('Failed to load segments');
            }

            const segments = await response.json();
            
            if (segments && segments.length > 0) {
                // Remove existing segments
                if (this.segmentsLayer) {
                    this.map.removeLayer(this.segmentsLayer);
                }

                const segmentLayers = segments.map(segment => {
                    // Determine color based on segment category
                    let color = '#6b7280'; // Default gray
                    switch (segment.category) {
                        case 'hc':
                            color = '#dc2626'; // Red for HC climbs
                            break;
                        case 'cat1':
                            color = '#ea580c'; // Orange for Cat 1
                            break;
                        case 'cat2':
                            color = '#d97706'; // Amber for Cat 2
                            break;
                        case 'cat3':
                            color = '#ca8a04'; // Yellow for Cat 3
                            break;
                        case 'cat4':
                            color = '#65a30d'; // Green for Cat 4
                            break;
                        case 'sprint':
                            color = '#0ea5e9'; // Blue for sprints
                            break;
                        case 'flat':
                            color = '#6b7280'; // Gray for flat
                            break;
                    }

                    // Create popup content with segment details
                    const popupContent = `
                        <div style="min-width: 200px;">
                            <h4 style="margin: 0 0 8px 0; color: #1f2937;">${segment.name}</h4>
                            <div style="margin-bottom: 8px;">
                                <span style="background: ${color}; color: white; padding: 2px 6px; border-radius: 4px; font-size: 11px; text-transform: uppercase;">
                                    ${segment.category}
                                </span>
                            </div>
                            <div style="font-size: 13px; color: #6b7280;">
                                <div>üìç ${segment.location || 'Unknown location'}</div>
                                <div>üìè ${(segment.distance / 1000).toFixed(1)} km</div>
                                <div>‚õ∞Ô∏è ${segment.elevation ? segment.elevation.toFixed(0) + 'm gain' : 'No elevation data'}</div>
                                <div>üìà ${segment.avg_grade ? segment.avg_grade.toFixed(1) + '% avg grade' : 'No grade data'}</div>
                                ${segment.stats ? `<div>üë• ${segment.stats.total_attempts} attempts</div>` : ''}
                                ${segment.stats?.record_time ? `<div>üèÜ Record: ${this.formatTime(segment.stats.record_time)}</div>` : ''}
                            </div>
                        </div>
                    `;

                    // Use segment path if available, otherwise create a line between bounds
                    let segmentPath;
                    if (segment.path && segment.path.length > 0) {
                        segmentPath = segment.path.map(point => [point[1], point[0]]); // Convert lng,lat to lat,lng
                    } else if (segment.bounds) {
                        // Create a simple line from SW to NE corner of bounds
                        segmentPath = [
                            [segment.bounds.min_lat, segment.bounds.min_lng],
                            [segment.bounds.max_lat, segment.bounds.max_lng]
                        ];
                    } else {
                        // Skip segments without location data
                        return null;
                    }

                    return L.polyline(segmentPath, {
                        color: color,
                        weight: 5,
                        opacity: 0.8,
                        className: 'segment-line'
                    }).bindPopup(popupContent);
                }).filter(layer => layer !== null); // Remove null segments

                this.segmentsLayer = L.layerGroup(segmentLayers).addTo(this.map);
                this.showNotification(`Showing ${segments.length} segments`, 'success');
            } else {
                // Show demo segments as fallback
                const demoSegments = [
                    { name: "Harbor Sprint", start: [center.lat, center.lng], end: [center.lat + 0.01, center.lng + 0.01], type: "sprint" },
                    { name: "Hilltop KOM", start: [center.lat + 0.02, center.lng - 0.01], end: [center.lat + 0.03, center.lng], type: "climb" }
                ];
                
                const segments = demoSegments.map(seg => {
                    return L.polyline([seg.start, seg.end], {
                        color: seg.type === 'sprint' ? '#00d4ff' : '#fc4c02',
                        weight: 6,
                        opacity: 0.7
                    }).bindPopup(`<strong>${seg.name}</strong><br>Type: ${seg.type}<br><em>Demo segment</em>`);
                });
                
                this.segmentsLayer = L.layerGroup(segments).addTo(this.map);
                this.showNotification('No segments found, showing demo data', 'info');
            }
        } catch (error) {
            console.error('Error loading segments:', error);
            this.showNotification('Failed to load segments', 'error');
        }
    }
    
    // Helper function to format time in seconds to readable format
    formatTime(seconds) {
        const hours = Math.floor(seconds / 3600);
        const minutes = Math.floor((seconds % 3600) / 60);
        const secs = seconds % 60;
        
        if (hours > 0) {
            return `${hours}:${minutes.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
        } else {
            return `${minutes}:${secs.toString().padStart(2, '0')}`;
        }
    }
    
    // Load and display saved routes
    loadSavedRoutes() {
        const savedRoutes = JSON.parse(localStorage.getItem('bikenode_routes') || '[]');
        this.savedRoutes = savedRoutes;
        
        const routesList = document.getElementById('savedRoutesList');
        if (savedRoutes.length === 0) {
            routesList.innerHTML = '<p class="no-routes">No saved routes yet</p>';
        } else {
            routesList.innerHTML = savedRoutes.slice(0, 3).map(route => `
                <div class="saved-route-item" onclick="routePlanner.loadRoute(${route.id})">
                    <strong>${route.name}</strong>
                    <span>${(route.stats?.distance / 1609.34).toFixed(1)} mi</span>
                </div>
            `).join('');
        }
    }
    
    // Show all routes page
    showAllRoutes() {
        window.location.href = '/routes-gallery/';
    }
    
    // Update route stats display
    updateRouteStats(route) {
        const distance = (route.summary.totalDistance / 1609.34).toFixed(1);
        const timeInMinutes = Math.round(route.summary.totalTime / 60);
        const hours = Math.floor(timeInMinutes / 60);
        const minutes = timeInMinutes % 60;
        
        // Update distance display
        document.getElementById('routeDistance').textContent = distance;
        
        // Update time (hidden in new UI, but keeping for compatibility)
        // document.getElementById('routeTime').textContent = `${hours}h ${minutes}m`;
        
        // Calculate elevation with gain and loss
        this.calculateElevation(route.coordinates);
    }
    
    showNotification(message, type = 'info') {
        const notification = document.createElement('div');
        notification.className = `notification notification-${type}`;
        notification.style.cssText = `
            position: fixed;
            top: 20px;
            right: 20px;
            background: var(--card-bg);
            border: 1px solid var(--accent);
            border-radius: 8px;
            padding: 12px 16px;
            color: var(--text-primary);
            z-index: 10000;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
            animation: slideIn 0.3s ease;
        `;
        notification.textContent = message;
        
        document.body.appendChild(notification);
        
        setTimeout(() => {
            notification.style.animation = 'slideOut 0.3s ease';
            setTimeout(() => {
                if (notification.parentNode) {
                    notification.parentNode.removeChild(notification);
                }
            }, 300);
        }, 3000);
    }
    
    showElevationDataSource(isRealData) {
        const header = document.querySelector('.profile-header');
        if (!header) return;
        
        // Remove existing indicator if any
        const existing = header.querySelector('.data-source-indicator');
        if (existing) existing.remove();
        
        // Create indicator
        const indicator = document.createElement('span');
        indicator.className = 'data-source-indicator';
        indicator.style.cssText = `
            font-size: 0.75rem;
            padding: 2px 8px;
            border-radius: 4px;
            margin-left: 12px;
            cursor: help;
        `;
        
        if (isRealData) {
            indicator.textContent = 'üìç Real Elevation Data';
            indicator.style.backgroundColor = 'rgba(16, 185, 129, 0.2)';
            indicator.style.color = '#10b981';
            indicator.title = 'Elevation data is under development. Accurate within ~30m radius, may capture nearby hillsides and not reflect actual road grade.';
        } else {
            indicator.textContent = '‚ö†Ô∏è Estimated Elevation';
            indicator.style.backgroundColor = 'rgba(251, 191, 36, 0.2)';
            indicator.style.color = '#fbbf24';
            indicator.title = 'Using estimated elevation data';
        }
        
        header.appendChild(indicator);
        
        // Add disclaimer notice if not already present
        const existingDisclaimer = document.querySelector('.elevation-disclaimer');
        if (!existingDisclaimer) {
            const disclaimer = document.createElement('div');
            disclaimer.className = 'elevation-disclaimer';
            disclaimer.style.cssText = `
                font-size: 0.7rem;
                color: var(--text-secondary);
                margin-top: 8px;
                padding: 8px 12px;
                background: rgba(251, 191, 36, 0.1);
                border-radius: 6px;
                border: 1px solid rgba(251, 191, 36, 0.2);
                line-height: 1.4;
            `;
            disclaimer.innerHTML = `
                <strong>Note:</strong> Elevation data is under development and accurate within ~30m radius. 
                May capture nearby hillsides and not reflect the actual road grade.
            `;
            
            const profileContainer = document.getElementById('elevationProfileContainer');
            profileContainer.insertBefore(disclaimer, profileContainer.children[1]);
        }
    }
    
    displayClimbs(climbs, routeData) {
        // Remove existing climb markers
        if (this.climbMarkers) {
            this.climbMarkers.forEach(marker => marker.remove());
        }
        this.climbMarkers = [];
        
        // Remove existing climb section
        const existingSection = document.querySelector('.climbs-section');
        if (existingSection) existingSection.remove();
        
        if (!climbs || climbs.length === 0) return;
        
        // Create climbs display section
        const climbsSection = document.createElement('div');
        climbsSection.className = 'climbs-section';
        climbsSection.style.cssText = `
            margin-top: 16px;
            padding: 12px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 8px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        `;
        
        const climbsHeader = document.createElement('h5');
        climbsHeader.textContent = `${climbs.length} Climb${climbs.length > 1 ? 's' : ''} Detected`;
        climbsHeader.style.cssText = `
            color: var(--text-primary);
            margin: 0 0 12px 0;
            font-size: 0.9rem;
            font-weight: 600;
        `;
        climbsSection.appendChild(climbsHeader);
        
        // Add each climb
        climbs.forEach((climb, index) => {
            const climbDiv = document.createElement('div');
            climbDiv.style.cssText = `
                display: flex;
                align-items: center;
                gap: 12px;
                margin-bottom: 8px;
                padding: 8px;
                background: rgba(255, 255, 255, 0.03);
                border-radius: 6px;
                cursor: pointer;
                transition: all 0.2s ease;
            `;
            
            climbDiv.onmouseover = () => {
                climbDiv.style.background = 'rgba(255, 255, 255, 0.08)';
                // Highlight on chart
                this.highlightClimbOnChart(climb);
            };
            
            climbDiv.onmouseout = () => {
                climbDiv.style.background = 'rgba(255, 255, 255, 0.03)';
                this.clearChartHighlight();
            };
            
            // Category badge
            const badge = document.createElement('span');
            badge.textContent = `Cat ${climb.category}`;
            badge.style.cssText = `
                padding: 4px 8px;
                background: ${climb.color};
                color: white;
                border-radius: 4px;
                font-size: 0.75rem;
                font-weight: 600;
                min-width: 50px;
                text-align: center;
            `;
            
            // Climb details
            const details = document.createElement('div');
            details.style.cssText = `flex: 1;`;
            details.innerHTML = `
                <div style="color: var(--text-primary); font-size: 0.85rem; font-weight: 500;">
                    Climb #${index + 1}
                </div>
                <div style="color: var(--text-secondary); font-size: 0.75rem;">
                    ${climb.distanceMi} mi ‚Ä¢ ${climb.gainFt} ft ‚Ä¢ ${climb.avgGrade.toFixed(1)}% avg
                </div>
            `;
            
            climbDiv.appendChild(badge);
            climbDiv.appendChild(details);
            climbsSection.appendChild(climbDiv);
            
            // Add markers on map for climb start
            if (routeData[climb.startIndex]) {
                const marker = L.marker(
                    [routeData[climb.startIndex].lat, routeData[climb.startIndex].lng],
                    {
                        icon: L.divIcon({
                            html: `<div style="
                                background: ${climb.color};
                                color: white;
                                width: 24px;
                                height: 24px;
                                border-radius: 50%;
                                display: flex;
                                align-items: center;
                                justify-content: center;
                                font-weight: bold;
                                font-size: 12px;
                                border: 2px solid white;
                                box-shadow: 0 2px 4px rgba(0,0,0,0.3);
                            ">${climb.category}</div>`,
                            className: 'climb-marker',
                            iconSize: [24, 24]
                        })
                    }
                ).addTo(this.map);
                
                marker.bindPopup(`
                    <strong>Category ${climb.category} Climb</strong><br>
                    Distance: ${climb.distanceMi} mi<br>
                    Elevation Gain: ${climb.gainFt} ft<br>
                    Average Grade: ${climb.avgGrade.toFixed(1)}%<br>
                    Max Grade: ${climb.maxGrade.toFixed(1)}%
                `);
                
                this.climbMarkers.push(marker);
            }
        });
        
        // Add to elevation profile container
        const profileContainer = document.getElementById('elevationProfileContainer');
        profileContainer.appendChild(climbsSection);
    }
    
    highlightClimbOnChart(climb) {
        // TODO: Add visual highlight on elevation chart for the climb section
        if (this.elevationChart && this.elevationData) {
            // Could add a shaded region or change line color for the climb section
        }
    }
    
    clearChartHighlight() {
        // TODO: Remove highlight from chart
    }
}

// Initialize route planner
let routePlanner;

function initializeRoutePlanner() {
    console.log('üöÄ Starting route planner initialization...');
    console.log('Leaflet available:', typeof L !== 'undefined');
    console.log('Leaflet Routing available:', typeof L !== 'undefined' && typeof L.Routing !== 'undefined');
    console.log('Chart.js available:', typeof Chart !== 'undefined');
    
    // Check if Leaflet is loaded
    if (typeof L === 'undefined') {
        console.error('‚ùå Leaflet not loaded!');
        const mapContainer = document.getElementById('routeMap');
        if (mapContainer) {
            mapContainer.innerHTML = '<div style="padding: 40px; text-align: center; color: var(--text-secondary);">Error: Map library not loaded. Please refresh the page.</div>';
        }
        return false;
    }
    
    if (typeof L.Routing === 'undefined') {
        console.error('‚ùå Leaflet Routing Machine not loaded!');
        const mapContainer = document.getElementById('routeMap');
        if (mapContainer) {
            mapContainer.innerHTML = '<div style="padding: 40px; text-align: center; color: var(--text-secondary);">Error: Routing library not loaded. Please refresh the page.</div>';
        }
        return false;
    }
    
    // Check if required DOM elements exist
    const mapContainer = document.getElementById('routeMap');
    const waypointBtn = document.getElementById('addWaypointMode');
    const useLocationBtn = document.getElementById('useMyLocation');
    
    console.log('Required elements check:', {
        mapContainer: !!mapContainer,
        waypointBtn: !!waypointBtn,
        useLocationBtn: !!useLocationBtn
    });
    
    if (!mapContainer) {
        console.error('‚ùå Map container not found!');
        return false;
    }
    
    try {
        console.log('‚úÖ All dependencies available, creating RoutePlanner...');
        routePlanner = new RoutePlanner();
        routePlanner.init();
        return true;
    } catch (error) {
        console.error('‚ùå Error initializing route planner:', error);
        console.error('Error stack:', error.stack);
        if (mapContainer) {
            mapContainer.innerHTML = '<div style="padding: 40px; text-align: center; color: var(--text-secondary);">Error initializing map. Please refresh the page.</div>';
        }
        return false;
    }
}

// Try multiple initialization strategies
document.addEventListener('DOMContentLoaded', function() {
    console.log('üìÑ DOM loaded...');
    
    // Try immediate initialization
    if (initializeRoutePlanner()) {
        console.log('‚úÖ Route planner initialized on DOM ready');
        return;
    }
    
    // If that fails, wait for scripts to load
    console.log('‚è≥ Waiting for scripts to load...');
    setTimeout(() => {
        if (initializeRoutePlanner()) {
            console.log('‚úÖ Route planner initialized after delay');
            return;
        }
        
        // Final attempt - wait longer
        console.log('‚è≥ Final initialization attempt...');
        setTimeout(() => {
            if (!initializeRoutePlanner()) {
                console.error('‚ùå All initialization attempts failed');
            }
        }, 2000);
    }, 1000);
});

</script>

